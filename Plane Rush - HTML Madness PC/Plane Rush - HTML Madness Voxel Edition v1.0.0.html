<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Plane Rush - HTML Madness</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'VT323', monospace; user-select: none; }
        
        /* FOND */
        #background-gradient {
            position: absolute; width: 100%; height: 100%; z-index: -2;
            background: linear-gradient(to bottom, #2e004f 0%, #8b005e 40%, #ff5500 70%, #ffd700 90%, #ffffcc 100%);
        }
        
        /* UI */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; padding: 25px; box-sizing: border-box; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; }
        .hud-top { display: flex; justify-content: space-between; width: 100%; align-items: flex-start; }
        .stats-group { display: flex; flex-direction: column; gap: 10px; }
        
        .hud-box { 
            background: rgba(80, 40, 10, 0.8); padding: 5px 15px; border: 4px solid #FFD700; 
            box-shadow: 4px 4px 0px #8B4513; color: #FFF; font-size: 35px; 
            display: flex; flex-direction: column; width: fit-content; 
        }
        .hud-label { font-size: 20px; color: #FFA500; text-transform: uppercase; }

        .status-bars { display: flex; flex-direction: column; gap: 10px; align-items: flex-end; }
        .bar-container { width: 250px; height: 25px; background: #3e2723; border: 4px solid #FFD700; position: relative; box-shadow: 4px 4px 0 #2e1713; }
        .bar-fill { width: 100%; height: 100%; transition: width 0.1s linear, background-color 0.2s; image-rendering: pixelated; }
        .bar-icon { position: absolute; top: -8px; left: -25px; font-size: 30px; text-shadow: 2px 2px 0 #000; z-index: 2; }
        
        #health-fill { background: #4caf50; }
        #energy-fill { background: #2196f3; } 

        #boost-container { width: 400px; height: 25px; background: rgba(0,0,0,0.5); border: 4px solid #FF00FF; margin: 0 auto; overflow: hidden; opacity: 0; transition: opacity 0.3s; box-shadow: 0 0 15px #FF00FF; }
        #boost-fill { width: 100%; height: 100%; background: repeating-linear-gradient(45deg, #FF00FF, #FF00FF 10px, #FFFFFF 10px, #FFFFFF 20px); transform-origin: left; transform: scaleX(0); transition: transform 0.1s linear; }
        #notif-label { text-align: center; color: #FF00FF; font-size: 40px; text-shadow: 2px 2px 0 #000; margin-bottom: 5px; opacity: 0; transition: opacity 0.3s; }

        /* MENUS */
        .overlay-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(80, 30, 0, 0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; transition: opacity 0.3s; }
        .control-choice { display: flex; gap: 20px; margin-top: 30px; }
        
        .btn { 
            background: #FFA500; color: #3e2723; border: 4px solid #3e2723; padding: 15px 50px; 
            font-size: 35px; font-family: 'VT323', monospace; cursor: pointer; 
            box-shadow: 6px 6px 0 #3e2723; transition: transform 0.1s; 
        }
        .btn:hover { transform: translate(-2px, -2px); box-shadow: 8px 8px 0 #3e2723; background: #FFD700; }
        
        .btn-small { padding: 10px 30px; font-size: 25px; margin-top: 15px; }

        .leaderboard-container { background: rgba(0,0,0,0.4); padding: 20px; border: 4px solid #FFD700; margin-bottom: 20px; width: 350px; color: white; text-align: center; font-size: 24px; }
        .score-entry { display: flex; justify-content: space-between; border-bottom: 2px dashed #8B4513; margin: 5px 0; }

        /* AUDIO SETTINGS */
        .audio-settings-box { background: rgba(0,0,0,0.8); border: 4px solid #00FFFF; padding: 30px; width: 400px; color: white; text-align: center; }
        .slider-group { margin: 20px 0; text-align: left; }
        .slider-label { display: flex; justify-content: space-between; color: #00FFFF; font-size: 24px; margin-bottom: 5px; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #FF00FF; }

        /* OVERLAYS */
        #damage-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 40%, rgba(255,0,0,0.6) 100%); opacity: 0; pointer-events: none; transition: opacity 0.1s; z-index: 50; }
        #heal-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 40%, rgba(0,255,0,0.4) 100%); opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 50; }
        #speed-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 50%, rgba(255, 0, 255, 0.2) 80%, rgba(255, 255, 255, 0.4) 100%); opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 40; mix-blend-mode: hard-light; }
        #shield-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 50%, rgba(0, 255, 0, 0.2) 100%); opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 40; mix-blend-mode: screen; }

        .hidden { display: none !important; }
        
        h1 { font-size: 90px; color: #FFD700; text-shadow: 6px 6px 0 #8B4513; margin: 0; line-height: 0.9; text-align: center; }
        h1 span { display: block; font-size: 50px; color: #FFA500; text-shadow: 4px 4px 0 #3e2723; transform: rotate(-2deg); margin-top: 10px; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
</head>
<body>
    <div id="background-gradient"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="stats-group">
                <div class="hud-box"><span class="hud-label">Score</span><span id="score-display">0</span></div>
                <div class="hud-box"><span class="hud-label">Distance</span><span id="dist-display">0 m</span></div>
            </div>
            <div class="status-bars">
                <div class="bar-container"><div class="bar-icon">ðŸ”§</div><div class="bar-fill" id="health-fill"></div></div>
                <div class="bar-container"><div class="bar-icon">â›½</div><div class="bar-fill" id="energy-fill"></div></div>
            </div>
        </div>
        <div style="text-align: center; margin-bottom: 20px;">
            <div id="notif-label">INVINCIBLE !</div>
            <div id="boost-container"><div id="boost-fill"></div></div>
        </div>
    </div>
    <div id="damage-overlay"></div><div id="heal-overlay"></div><div id="speed-overlay"></div><div id="shield-overlay"></div>

    <!-- START SCREEN -->
    <div id="start-screen" class="overlay-screen">
        <h1>PLANE RUSH<span>HTML Madness</span></h1>
        
        <div class="leaderboard-container">
            <div style="color:#FFD700; margin-bottom:10px;">MEILLEURS PILOTES</div>
            <div id="lb-start"></div>
        </div>

        <button class="btn btn-small" onclick="openAudioSettings()" style="background:#00FFFF; border-color:#008888; color:#004444; margin-bottom: 10px;">ðŸ”Š AUDIO</button>

        <p style="color:#FFF; font-size: 20px; text-shadow: 2px 2px 0 #000; margin: 10px 0;">CHOISISSEZ VOS COMMANDES</p>
        <div class="control-choice">
            <button class="btn" onclick="startGame('mouse')">SOURIS</button>
            <button class="btn" onclick="startGame('keyboard')">CLAVIER</button>
        </div>
    </div>

    <!-- AUDIO SETTINGS MENU -->
    <div id="audio-screen" class="overlay-screen hidden">
        <div class="audio-settings-box">
            <h2 style="color:#00FFFF; margin-bottom: 30px;">REGLAGES AUDIO</h2>
            
            <div class="slider-group">
                <div class="slider-label"><span>MUSIQUE</span> <span id="vol-music-val">40%</span></div>
                <input type="range" min="0" max="100" value="40" oninput="updateAudioSettings('music', this.value)">
            </div>

            <div class="slider-group">
                <div class="slider-label"><span>MOTEUR</span> <span id="vol-engine-val">30%</span></div>
                <input type="range" min="0" max="100" value="30" oninput="updateAudioSettings('engine', this.value)">
            </div>

            <div class="slider-group">
                <div class="slider-label"><span>EFFETS (SFX)</span> <span id="vol-sfx-val">50%</span></div>
                <input type="range" min="0" max="100" value="50" oninput="updateAudioSettings('sfx', this.value)">
            </div>

            <button class="btn" onclick="closeAudioSettings()">RETOUR</button>
        </div>
    </div>
    
    <div id="pause-screen" class="overlay-screen hidden"><h1>PAUSE</h1><button class="btn" onclick="togglePause()">REPRENDRE</button></div>
    
    <div id="game-over-screen" class="overlay-screen hidden">
        <h1 style="color:#ff3333; text-shadow: 4px 4px 0 #3e2723;">CRASH!</h1>
        <div class="hud-box" style="align-items: center; margin: 20px 0;">
            <span class="hud-label">Rapport Final</span>
            <span id="final-score">Score: 0</span>
            <span id="final-dist" style="font-size:25px; color:#aaa">Dist: 0m</span>
        </div>
        <div class="leaderboard-container"><div style="color:#FFD700; margin-bottom:10px;">TOP 5</div><div id="lb-end"></div></div>
        <button class="btn" onclick="resetGame()">RÃ‰ESSAYER</button>
    </div>

    <script>
        // GLOBALS POUR AUDIO VOLUMES
        const VOLUMES = { music: 0.4, engine: 0.3, sfx: 0.5 };

        const AudioSys = { 
            ctx: null, engineOsc: null, engineGain: null, bgMusic: null,
            init: function() { 
                if(!this.ctx) { 
                    this.ctx = new (window.AudioContext||window.webkitAudioContext)(); 
                    
                    // SFX Synth (Moteur)
                    this.engineOsc = this.ctx.createOscillator(); 
                    this.engineGain = this.ctx.createGain(); 
                    this.engineOsc.type = 'sawtooth'; 
                    this.engineOsc.frequency.value = 60; 
                    // Gain initial Ã  0, sera modulÃ© par updateEngine
                    this.engineGain.gain.value = 0; 
                    this.engineOsc.connect(this.engineGain); 
                    this.engineGain.connect(this.ctx.destination); 
                    this.engineOsc.start(); 

                    // Musique de fond
                    this.bgMusic = new Audio('music.mp3');
                    this.bgMusic.loop = true;
                    this.bgMusic.volume = VOLUMES.music;
                } 
                if(this.ctx.state === 'suspended') this.ctx.resume();
            },
            updateEngine: function(ratio) { 
                if(!this.engineOsc) return; 
                // Pitch
                this.engineOsc.frequency.setTargetAtTime(60 + (ratio * 100), this.ctx.currentTime, 0.1); 
                // Volume Dynamique * Volume Utilisateur
                const dynamicVol = 0.05 + (ratio * 0.05);
                this.engineGain.gain.setTargetAtTime(dynamicVol * (VOLUMES.engine * 2), this.ctx.currentTime, 0.1); 
            },
            play: function(f,t,d,v=0.1) { 
                if(!this.ctx)return; const o=this.ctx.createOscillator(),g=this.ctx.createGain(); 
                o.type=t; o.frequency.value=f; 
                // Volume du son * Volume Utilisateur
                g.gain.setValueAtTime(v * VOLUMES.sfx, this.ctx.currentTime); 
                g.gain.exponentialRampToValueAtTime(0.01,this.ctx.currentTime+d); 
                o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(this.ctx.currentTime+d); 
            }, 
            coin:()=>AudioSys.play(600,'square',0.1), 
            hit:()=>AudioSys.play(100,'sawtooth',0.3, 0.3), 
            boost:()=>AudioSys.play(300,'square',0.5,0.1), 
            smash:()=>AudioSys.play(50,'square',0.2,0.5), 
            heal:()=>AudioSys.play(600,'sine',0.5,0.2), 
            fuel:()=>AudioSys.play(200,'sawtooth',0.3,0.1), 
            gameOver:()=>{ 
                AudioSys.play(60,'sawtooth',1.0, 0.5); 
                if(AudioSys.engineGain) AudioSys.engineGain.gain.setTargetAtTime(0, AudioSys.ctx.currentTime, 0.1); 
                if(AudioSys.bgMusic) AudioSys.bgMusic.pause();
            },
            startMusic: () => {
                if(AudioSys.bgMusic) {
                    AudioSys.bgMusic.volume = VOLUMES.music;
                    AudioSys.bgMusic.currentTime = 0;
                    AudioSys.bgMusic.play().catch(e => console.log("Audio play failed:", e));
                }
            },
            pauseMusic: (pause) => {
                if(AudioSys.bgMusic) {
                    if(pause) AudioSys.bgMusic.pause();
                    else AudioSys.bgMusic.play();
                }
            },
            updateMusicVolume: () => {
                if(AudioSys.bgMusic) AudioSys.bgMusic.volume = VOLUMES.music;
            }
        };
        
        // --- UI FUNCTIONS ---
        function openAudioSettings() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('audio-screen').classList.remove('hidden');
        }
        function closeAudioSettings() {
            document.getElementById('audio-screen').classList.add('hidden');
            document.getElementById('start-screen').classList.remove('hidden');
        }
        function updateAudioSettings(type, val) {
            const pct = parseInt(val);
            const decimal = pct / 100;
            
            if(type === 'music') {
                VOLUMES.music = decimal;
                document.getElementById('vol-music-val').innerText = pct + '%';
                AudioSys.updateMusicVolume();
            } else if (type === 'engine') {
                VOLUMES.engine = decimal;
                document.getElementById('vol-engine-val').innerText = pct + '%';
            } else if (type === 'sfx') {
                VOLUMES.sfx = decimal;
                document.getElementById('vol-sfx-val').innerText = pct + '%';
            }
        }

        // --- CONFIG ---
        const CONFIG = { 
            baseSpeed: 1.8, maxBoostSpeed: 4.5, chunkSize: 100, chunkCount: 14,
            colors: {
                birdBody: 0x5D4037, birdWing: 0x111111,
                cloud: 0xFFFFFF, rocket: 0xFF00FF, wrench: 0xC0C0C0, fuel: 0xFF0000, missile: 0x00FF00,
                terrainBase: 0x8B4513, terrainVar1: 0xA0522D, terrainVar2: 0xCD853F, 
                planeMain: 0xD32F2F, planeSec: 0xFFFFFF   
            }
        };
        
        let scene, camera, renderer, plane, propeller, sunMesh;
        let terrainChunks = [], objects = [], particles = [];
        let score = 0, health = 100, energy = 50, gameSpeed = CONFIG.baseSpeed, distance = 0;
        let isPlaying = false, isPaused = false, frameCount = 0;
        let controlMode = 'mouse'; let mouseX = 0, mouseY = 0; let keyInput = { x: 0, y: 0, boost: false };
        let invincibleTimer = 0; const INVINCIBLE_DURATION = 200;
        let birdShieldTimer = 0; const BIRD_SHIELD_DURATION = 600; 
        let bounceForce = 0, wallHitTimer = 0, isInputLocked = false;
        const simplex = new SimplexNoise();

        function getScores() { const s=localStorage.getItem('planeRushFinalScores'); return s?JSON.parse(s):[]; }
        function saveScore(ns, dist) { let s=getScores(); s.push({score: ns, dist: dist}); s.sort((a,b)=>b.score-a.score); s=s.slice(0,5); localStorage.setItem('planeRushFinalScores',JSON.stringify(s)); return s; }
        function updateLeaderboardUI() { const s=getScores(); while(s.length < 5) s.push({score:0, dist:0}); const html=s.map((v,i)=>`<div class="score-entry"><span>#${i+1} ${Math.floor(v.dist)}m</span><span>${v.score}</span></div>`).join(''); document.getElementById('lb-start').innerHTML=html; document.getElementById('lb-end').innerHTML=html; }

        function getDifficultyMultiplier() { return 1 + (distance / 2000); }

        function getTerrainHeight(x, z) {
            let noise = simplex.noise2D(x * 0.02, z * 0.02);
            let h = -12; 
            if(Math.abs(x) > 30) {
                let canyonH = Math.max(0, noise * 40 + (Math.abs(x) - 30) * 1.5);
                h += Math.floor(canyonH / 4) * 4;
            }
            let spikeNoise = simplex.noise2D(x * 0.08, z * 0.08); 
            if (spikeNoise > 0.82 && Math.abs(x) < 25) {
                let spikeH = (spikeNoise - 0.82) * 120;
                h += Math.floor(spikeH / 4) * 4;
            }
            return h;
        }

        function init() {
            updateLeaderboardUI();
            scene = new THREE.Scene(); 
            scene.fog = new THREE.Fog(0xFFD700, 100, 400);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 24);

            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.BasicShadowMap; 
            document.body.appendChild(renderer.domElement);
            
            const sunLight = new THREE.DirectionalLight(0xffeba1, 1.2); sunLight.position.set(50, 80, 50); sunLight.castShadow = true; 
            sunLight.shadow.mapSize.width = 1024; sunLight.shadow.mapSize.height = 1024;
            sunLight.shadow.camera.left = -100; sunLight.shadow.camera.right = 100; scene.add(sunLight); 
            const ambient = new THREE.AmbientLight(0xffaf7b, 0.6); scene.add(ambient);

            const sunGeo = new THREE.CircleGeometry(60, 32);
            const sunMat = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
            sunMesh = new THREE.Mesh(sunGeo, sunMat);
            scene.add(sunMesh);

            createVoxelPlane();
            for(let i=0; i<CONFIG.chunkCount; i++) terrainChunks.push(createChunk(-i * CONFIG.chunkSize));

            document.addEventListener('mousemove', e => { 
                if(!isPaused && controlMode === 'mouse') { mouseX = (e.clientX/window.innerWidth)*2-1; mouseY = -(e.clientY/window.innerHeight)*2+1; } 
            });
            document.addEventListener('mousedown', () => { if(!isPaused && isPlaying && controlMode === 'mouse') keyInput.boost = true; });
            document.addEventListener('mouseup', () => { keyInput.boost = false; });

            document.addEventListener('keydown', e => { 
                if(e.key==="Escape" && isPlaying) togglePause();
                if(controlMode === 'keyboard') {
                    if(e.key === "ArrowUp") keyInput.y = 1; if(e.key === "ArrowDown") keyInput.y = -1;
                    if(e.key === "ArrowLeft") keyInput.x = -1; if(e.key === "ArrowRight") keyInput.x = 1;
                    if(e.key === " ") keyInput.boost = true;
                }
            });
            document.addEventListener('keyup', e => {
                if(controlMode === 'keyboard') {
                    if(e.key === "ArrowUp" || e.key === "ArrowDown") keyInput.y = 0;
                    if(e.key === "ArrowLeft" || e.key === "ArrowRight") keyInput.x = 0;
                    if(e.key === " ") keyInput.boost = false;
                }
            });

            window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
            animate();
        }

        function createVoxelBox(w, h, d, color, x, y, z, emissive=false) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshPhongMaterial({color: color, flatShading: true, emissive: emissive ? color : 0x000000, emissiveIntensity: emissive ? 0.5 : 0});
            const mesh = new THREE.Mesh(geo, mat); mesh.position.set(x, y, z); mesh.castShadow = true; mesh.receiveShadow = true;
            const edges = new THREE.EdgesGeometry(geo);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
            mesh.add(line);
            return mesh;
        }

        function createVoxelPlane() {
            plane = new THREE.Group();
            plane.add(createVoxelBox(2, 2, 6, 0xD32F2F, 0, 0, 0));
            plane.add(createVoxelBox(10, 0.5, 3, 0xFFFFFF, 0, 1.5, 0)); plane.add(createVoxelBox(8, 0.5, 3, 0xFFFFFF, 0, -1, 0));
            plane.add(createVoxelBox(4, 0.5, 2, 0xFFFFFF, 0, 0.5, 2.5)); plane.add(createVoxelBox(0.5, 2.5, 2.1, 0xD32F2F, 0, 1.1, 2.5)); 
            plane.add(createVoxelBox(0.2, 2.5, 0.5, 0x333333, -3, 0, 0)); plane.add(createVoxelBox(0.2, 2.5, 0.5, 0x333333, 3, 0, 0));
            propeller = createVoxelBox(6, 0.5, 0.5, 0x333333, 0, 0, -3.2); plane.add(propeller);
            scene.add(plane);
        }

        function createChunk(zPos) {
            const geo = new THREE.PlaneGeometry(200, CONFIG.chunkSize, 50, 25); geo.rotateX(-Math.PI/2);
            const pos = geo.attributes.position;
            const colors = [];
            for(let i=0; i<pos.count; i++) {
                let x = pos.getX(i); let zGlobal = zPos + pos.getZ(i); let rawH = getTerrainHeight(x, zGlobal);
                pos.setY(i, Math.floor(rawH / 2) * 2);
                let noiseCol = simplex.noise2D(x*0.05, zGlobal*0.05);
                let c = new THREE.Color(CONFIG.colors.terrainBase);
                if(noiseCol > 0.3) c.setHex(CONFIG.colors.terrainVar1); if(noiseCol < -0.3) c.setHex(CONFIG.colors.terrainVar2);
                colors.push(c.r, c.g, c.b);
            }
            geo.computeVertexNormals();
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const mat = new THREE.MeshPhongMaterial({vertexColors: true, flatShading:true, shininess:0});
            const m = new THREE.Mesh(geo, mat);
            m.position.z = zPos; m.receiveShadow = true; 
            const edges = new THREE.EdgesGeometry(geo, 15);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
            m.add(line);
            scene.add(m);
            return m;
        }

        function spawnObject() {
            const r = Math.random(); const diff = getDifficultyMultiplier();
            let birdProb = Math.min(0.6, 0.2 * diff);
            let wrenchProb = Math.max(0.01, 0.05 / diff);
            let fuelProb = Math.max(0.01, 0.05 / diff);
            
            let type;
            if (r < birdProb) type = 'bird';
            else if (r < birdProb + wrenchProb) type = 'wrench';
            else if (r < birdProb + wrenchProb + fuelProb) type = 'fuel';
            else if (r < birdProb + wrenchProb + fuelProb + 0.03) type = 'rocket';
            else if (r < birdProb + wrenchProb + fuelProb + 0.06) type = 'missile';
            else type = 'cloud';

            let m;
            if(type==='bird') { 
                m = new THREE.Group();
                const body = createVoxelBox(1, 1, 1.5, CONFIG.colors.birdBody, 0, 0, 0); 
                const wingLGroup = new THREE.Group(); const wingL = createVoxelBox(2, 0.2, 1, CONFIG.colors.birdWing, -1.0, 0, 0); wingLGroup.add(wingL); wingLGroup.position.set(-0.5, 0.2, 0);
                const wingRGroup = new THREE.Group(); const wingR = createVoxelBox(2, 0.2, 1, CONFIG.colors.birdWing, 1.0, 0, 0); wingRGroup.add(wingR); wingRGroup.position.set(0.5, 0.2, 0);
                m.add(body, wingLGroup, wingRGroup); m.userData = {type:'bird', wings:[wingLGroup, wingRGroup], dead: false};
            } 
            else if(type==='fuel') {
                m = new THREE.Group();
                m.add(createVoxelBox(1.5, 2, 1.5, CONFIG.colors.fuel, 0, 0, 0));
                m.add(createVoxelBox(0.2, 0.5, 1, 0x333333, 0, 1.2, 0));
                m.userData = {type:'fuel'};
            }
            else if(type==='missile') {
                m = new THREE.Group();
                // BOUCLIER VOXEL (Plaque argent + coeur vert)
                m.add(createVoxelBox(1.5, 1.8, 0.2, 0xCCCCCC, 0, 0, 0));
                m.add(createVoxelBox(1.0, 1.3, 0.3, CONFIG.colors.missile, 0, 0, 0, true));
                m.userData = {type:'missile'};
            }
            else if(type==='rocket') {
                m = new THREE.Group();
                m.add(createVoxelBox(1, 1, 3, CONFIG.colors.rocket, 0, 0, 0, true));
                m.add(createVoxelBox(1.2, 1.2, 0.5, 0xFFFFFF, 0, 0, -1.5));
                m.userData = {type:'rocket'};
            }
            else if(type==='wrench') {
                m = new THREE.Group();
                m.add(createVoxelBox(0.5, 3, 0.5, CONFIG.colors.wrench, 0, 0, 0));
                m.add(createVoxelBox(1.5, 0.8, 0.5, CONFIG.colors.wrench, 0, 1.2, 0));
                m.userData = {type:'wrench'};
            }
            else { 
                m = new THREE.Group();
                const core = createVoxelBox(2, 2, 2, CONFIG.colors.cloud, 0, 0, 0);
                const p1 = createVoxelBox(1.5, 1.5, 1.5, CONFIG.colors.cloud, 1.2, 0, 0);
                const p2 = createVoxelBox(1.5, 1.5, 1.5, CONFIG.colors.cloud, -1.2, 0.2, 0);
                m.add(core, p1, p2); m.userData = {type:'cloud'};
            }
            
            const spawnZ = plane.position.z - 400; const spawnX = (Math.random()-0.5) * 70; 
            
            // ANTI-CLIPPING
            const h1 = getTerrainHeight(spawnX, spawnZ);
            const h2 = getTerrainHeight(spawnX - 2, spawnZ);
            const h3 = getTerrainHeight(spawnX + 2, spawnZ);
            const safeH = Math.max(h1, h2, h3);

            const spawnY = Math.max(safeH + 4, (Math.random() * 10) - 2);
            m.position.set(spawnX, spawnY, spawnZ); scene.add(m); objects.push(m);
        }

        function spawnParticles(pos, c, count=6) { 
            for(let i=0;i<count;i++){
                let m=new THREE.Mesh(new THREE.BoxGeometry(0.8,0.8,0.8),new THREE.MeshBasicMaterial({color:c}));
                m.position.copy(pos); m.userData={vel:new THREE.Vector3((Math.random()-.5)*3,(Math.random()-.5)*3,(Math.random()-.5)*3)};
                const edges = new THREE.EdgesGeometry(m.geometry); const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color:0x000000})); m.add(line);
                scene.add(m); particles.push(m);
            } 
        }
        
        function checkCollision(plane, obj) {
            const dx = Math.abs(plane.position.x - obj.position.x);
            const dy = Math.abs(plane.position.y - obj.position.y);
            const dz = Math.abs(plane.position.z - obj.position.z);
            if (dx < 5 && dy < 2.5 && dz < 3) return true;
            return false;
        }

        function startGame(mode){ controlMode = mode; AudioSys.init(); AudioSys.startMusic(); isPlaying=true;document.getElementById('start-screen').classList.add('hidden');resetLogic(); }
        function togglePause(){
            isPaused=!isPaused;document.getElementById('pause-screen').classList.toggle('hidden'); 
            if(isPaused) { if(AudioSys.engineGain) AudioSys.engineGain.gain.value = 0; AudioSys.pauseMusic(true); } 
            else { AudioSys.pauseMusic(false); }
        }
        function resetGame(){document.getElementById('game-over-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden');}
        
        function resetLogic(){
            score=0; distance=0; health=100; energy=50; invincibleTimer=0; birdShieldTimer=0;
            gameSpeed=CONFIG.baseSpeed; bounceForce = 0; wallHitTimer = 0; isInputLocked = false;
            mouseX=0; mouseY=0; keyInput.x=0; keyInput.y=0;
            objects.forEach(o=>scene.remove(o));objects=[]; particles.forEach(p=>scene.remove(p));particles=[];
            plane.position.set(0,0,0);plane.rotation.set(0,0,0);
            terrainChunks.forEach(c=>scene.remove(c));terrainChunks=[];
            for(let i=0;i<CONFIG.chunkCount;i++)terrainChunks.push(createChunk(-i*CONFIG.chunkSize));
            updateHUD();
        }

        function activateInvincibleBoost() { invincibleTimer = INVINCIBLE_DURATION; AudioSys.boost(); document.getElementById('boost-container').style.opacity = 1; document.getElementById('notif-label').innerText="HYPER VITESSE!"; document.getElementById('notif-label').style.color="#FF00FF"; document.getElementById('notif-label').style.opacity=1; document.getElementById('speed-overlay').style.opacity = 1; }
        function activateBirdShield() { birdShieldTimer = BIRD_SHIELD_DURATION; AudioSys.boost(); document.getElementById('boost-container').style.opacity = 1; document.getElementById('notif-label').innerText="BOUCLIER ANTI-OISEAUX"; document.getElementById('notif-label').style.color="#00FF00"; document.getElementById('notif-label').style.opacity=1; document.getElementById('shield-overlay').style.opacity = 1; }

        function takeDamage(amount) {
             if (invincibleTimer > 0) return; 
             health -= amount; AudioSys.hit(); spawnParticles(plane.position, 0xFF0000); 
             camera.position.x += (Math.random()-0.5)*3; camera.position.y += (Math.random()-0.5)*3; 
             const ov = document.getElementById('damage-overlay'); ov.style.opacity=1; setTimeout(()=>ov.style.opacity=0,200); 
             if(health<=0){ health = 0; isPlaying=false; AudioSys.gameOver(); document.getElementById('final-score').innerText=`${score} PTS`; document.getElementById('final-dist').innerText=`${Math.floor(distance)}M`; saveScore(score, distance); updateLeaderboardUI(); document.getElementById('game-over-screen').classList.remove('hidden'); }
             updateHUD();
        }
        
        function healFull() { health = 100; AudioSys.heal(); const ov = document.getElementById('heal-overlay'); ov.style.opacity=1; setTimeout(()=>ov.style.opacity=0,300); updateHUD(); }
        function refillEnergy() { energy = Math.min(100, energy + 50); AudioSys.fuel(); updateHUD(); }

        function updateHUD() { 
            document.getElementById('score-display').innerText=score; document.getElementById('dist-display').innerText=Math.floor(distance) + " m";
            const hb = document.getElementById('health-fill'); hb.style.width = health + "%";
            const eb = document.getElementById('energy-fill'); eb.style.width = energy + "%";
        }

        function animate() {
            requestAnimationFrame(animate); if(isPaused)return;
            
            if(!isPlaying){ plane.rotation.z=Math.sin(Date.now()*0.001)*0.05; propeller.rotation.z+=0.2; renderer.render(scene, camera); return; }
            
            frameCount++; distance += gameSpeed * 0.1;
            if(wallHitTimer > 0) wallHitTimer--;

            sunMesh.position.z = plane.position.z - 400; sunMesh.position.x = 0; sunMesh.position.y = 30;

            const speedRatio = (gameSpeed - CONFIG.baseSpeed) / (CONFIG.maxBoostSpeed - CONFIG.baseSpeed);
            AudioSys.updateEngine(Math.max(0, speedRatio));

            if (birdShieldTimer > 0) {
                birdShieldTimer--;
                document.getElementById('boost-fill').style.transform = `scaleX(${birdShieldTimer / BIRD_SHIELD_DURATION})`;
                document.getElementById('boost-fill').style.background = "#00FF00";
                if(birdShieldTimer <= 0) { document.getElementById('boost-container').style.opacity = 0; document.getElementById('notif-label').style.opacity = 0; document.getElementById('shield-overlay').style.opacity = 0; }
            }

            if (invincibleTimer > 0) {
                invincibleTimer--; gameSpeed = CONFIG.maxBoostSpeed; 
                document.getElementById('boost-fill').style.transform = `scaleX(${invincibleTimer / INVINCIBLE_DURATION})`;
                document.getElementById('boost-fill').style.background = "#FF00FF";
                if (invincibleTimer <= 0) { gameSpeed = CONFIG.baseSpeed + (distance / 5000); document.getElementById('boost-container').style.opacity = 0; document.getElementById('notif-label').style.opacity = 0; document.getElementById('speed-overlay').style.opacity = 0; }
            } else {
                if (keyInput.boost && energy > 0) { gameSpeed = 3.5; energy -= 0.5; } 
                else { gameSpeed = CONFIG.baseSpeed + (distance / 5000); }
            }
            updateHUD(); 

            if(gameSpeed > 3 && frameCount % 3 === 0) {
                const color = invincibleTimer > 0 ? 0xFF00FF : 0x00FFFF;
                const p = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), new THREE.MeshBasicMaterial({color:color}));
                p.position.copy(plane.position); p.position.z += 2; p.userData = {vel: new THREE.Vector3((Math.random()-.5)*0.5, (Math.random()-.5)*0.5, 2)};
                scene.add(p); particles.push(p);
            }
            
            // INPUT
            let targetX, targetY;
            if (isInputLocked) {
                targetX = 0; targetY = 0;
            } else {
                if(controlMode === 'mouse') {
                    targetX = mouseX * 60; targetY = mouseY * 15;
                } else {
                    if(keyInput.x !== 0) mouseX += keyInput.x * 0.015; else mouseX *= 0.9;
                    if(keyInput.y !== 0) mouseY += keyInput.y * 0.04; else mouseY *= 0.9;
                    mouseX = Math.max(-1, Math.min(1, mouseX));
                    mouseY = Math.max(-1, Math.min(1, mouseY));
                    targetX = mouseX * 60; targetY = mouseY * 15;
                }
            }
            
            bounceForce *= 0.9; 
            plane.position.x += (targetX - plane.position.x) * 0.1 + bounceForce; 
            plane.position.y += (targetY - plane.position.y) * 0.1;
            plane.position.z -= gameSpeed;

            const terrainHeight = getTerrainHeight(plane.position.x, plane.position.z);
            if (plane.position.y < terrainHeight + 1.0) {
                if (invincibleTimer > 0) { plane.position.y = terrainHeight + 2; spawnParticles(plane.position, 0xffaa00, 3); } 
                else { takeDamage(20); plane.position.y = terrainHeight + 3; }
            }
            
            if (Math.abs(plane.position.x) > 32) {
                if(invincibleTimer <= 0 && wallHitTimer <= 0) {
                    takeDamage(50); wallHitTimer = 60; isInputLocked = true; setTimeout(() => { isInputLocked = false; }, 500);
                    bounceForce = (plane.position.x > 0) ? -3.5 : 3.5; spawnParticles(plane.position, 0x8B4513, 10);
                } else if(invincibleTimer > 0) {
                    bounceForce = (plane.position.x > 0) ? -1.0 : 1.0;
                }
            }

            plane.rotation.z = -(targetX - plane.position.x) * 0.05 - (bounceForce * 0.5); 
            plane.rotation.x = (targetY - plane.position.y) * 0.03; 
            propeller.rotation.z += (gameSpeed * 0.5);

            let fovTarget = gameSpeed > 2.5 ? 80 : 60; camera.fov += (fovTarget - camera.fov) * 0.05; camera.updateProjectionMatrix();
            camera.position.x += (plane.position.x*0.5 - camera.position.x)*0.1; 
            camera.position.y += (plane.position.y*0.5+8 - camera.position.y)*0.1; 
            camera.position.z = plane.position.z + 24; 
            camera.lookAt(plane.position.x, plane.position.y, plane.position.z - 50);

            if(terrainChunks[0].position.z > plane.position.z + CONFIG.chunkSize) {
                scene.remove(terrainChunks[0]); terrainChunks.shift();
                terrainChunks.push(createChunk(terrainChunks[terrainChunks.length-1].position.z - CONFIG.chunkSize));
            }

            const spawnRate = gameSpeed > 2.5 ? 6 : 10;
            if(frameCount % spawnRate === 0) spawnObject();

            for(let i=objects.length-1; i>=0; i--) {
                let o = objects[i]; 
                
                if(o.userData.type === 'bird') {
                    if (o.userData.dead) { o.position.y -= 1.0; o.rotation.x += 0.2; o.rotation.z += 0.2; } 
                    else { o.userData.wings[0].rotation.z = Math.sin(frameCount * 0.5); o.userData.wings[1].rotation.z = -Math.sin(frameCount * 0.5); o.position.z += 0.4; }
                }
                if(['rocket','wrench','cloud','fuel','missile'].includes(o.userData.type)) o.rotation.y += 0.05;

                if(!o.userData.dead && checkCollision(plane, o)) { 
                    if(o.userData.type==='bird'){ 
                        if (invincibleTimer > 0) { score += 50; AudioSys.smash(); spawnParticles(o.position, 0xff3333, 10); o.userData.dead = true; } 
                        else if (birdShieldTimer > 0) { score += 20; AudioSys.hit(); o.userData.dead = true; }
                        else { takeDamage(20); }
                    }
                    else if(o.userData.type==='rocket') { activateInvincibleBoost(); score+=50; spawnParticles(o.position, CONFIG.colors.rocket, 10); scene.remove(o); objects.splice(i,1); }
                    else if(o.userData.type==='wrench') { healFull(); spawnParticles(o.position, CONFIG.colors.wrench, 10); scene.remove(o); objects.splice(i,1); }
                    else if(o.userData.type==='fuel') { refillEnergy(); spawnParticles(o.position, CONFIG.colors.fuel, 10); scene.remove(o); objects.splice(i,1); }
                    else if(o.userData.type==='missile') { activateBirdShield(); spawnParticles(o.position, CONFIG.colors.missile, 10); scene.remove(o); objects.splice(i,1); }
                    else { score+=10; AudioSys.coin(); spawnParticles(o.position, CONFIG.colors.cloud, 5); scene.remove(o); objects.splice(i,1); } 
                } 
                else if(o.position.z>plane.position.z+20 || o.position.y < -30){scene.remove(o);objects.splice(i,1);}
            }
            
            for(let i=particles.length-1; i>=0; i--){ 
                particles[i].position.add(particles[i].userData.vel); particles[i].rotation.x += 0.1; particles[i].scale.multiplyScalar(0.9); 
                if(particles[i].scale.x<0.05){scene.remove(particles[i]);particles.splice(i,1);} 
            }
            renderer.render(scene, camera);
        }
        init();
    </script>
</body>
</html>