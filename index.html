<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Plane Rush - Ultimate Hardcore</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: 'VT323', monospace; user-select: none; 
            -webkit-touch-callout: none; -webkit-user-select: none;
            touch-action: none; overscroll-behavior: none;
        }
        
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #110022; }
        ::-webkit-scrollbar-thumb { background: #FF00FF; border-radius: 4px; }

        #background-gradient {
            position: absolute; width: 100%; height: 100%; z-index: -2;
            background: linear-gradient(to bottom, #120024 0%, #4b0082 30%, #ff0055 60%, #ff8800 80%, #ffbd55 100%);
        }
        
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; padding: 10px; box-sizing: border-box; 
            z-index: 10; display: flex; flex-direction: column; justify-content: space-between; 
        }

        #overdrive-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 5;
            box-shadow: inset 0 0 100px rgba(255, 215, 0, 0.6), inset 0 0 20px rgba(255, 215, 0, 0.8);
            opacity: 0; transition: opacity 0.5s;
            mix-blend-mode: screen;
        }
        .pulsing-gold { animation: pulseGold 1s infinite alternate; }
        @keyframes pulseGold { from { opacity: 0.6; } to { opacity: 1.0; } }

        .hud-top { 
            display: flex; flex-direction: column; width: 100%; align-items: center; gap: 5px; 
            margin-top: env(safe-area-inset-top); 
        }

        .status-bars { 
            display: flex; flex-direction: row; gap: 8px; width: 100%; 
            justify-content: space-between; align-items: center; margin-bottom: 5px; 
            pointer-events: auto; 
        }

        .bar-wrapper { position: relative; flex: 1; height: 24px; background: #111; border: 2px solid #FFF; display: flex; align-items: center; padding: 1px; }
        .bar-icon-box { width: 24px; height: 100%; background: #222; display: flex; align-items: center; justify-content: center; border-right: 2px solid #FFF; margin-right: 2px; color: #FFF; font-size: 16px; z-index: 2; }
        .bar-fill-container { flex-grow: 1; height: 100%; position: relative; background: #2a0e2a; }
        .bar-fill { height: 100%; width: 100%; transition: width 0.1s linear; position: relative; }
        .bar-fill::after { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.2) 4px); }

        #health-wrapper { border-color: #FF0055; margin-right: 2px;}
        #health-wrapper .bar-icon-box { background: #FF0055; color: #111; border-right-color: #FF0055; }
        #health-fill { background: linear-gradient(90deg, #880000, #FF0055); box-shadow: 0 0 5px #FF0055; }
        #energy-wrapper { border-color: #00FFFF; margin-left: 2px;}
        #energy-wrapper .bar-icon-box { background: #00FFFF; color: #111; border-right-color: #00FFFF; }
        #energy-fill { background: linear-gradient(90deg, #004488, #00FFFF); box-shadow: 0 0 5px #00FFFF; }

        #pause-btn-center {
            width: 40px; height: 32px; 
            background: rgba(0, 0, 0, 0.8); border: 2px solid #FFF;
            color: #FFF; font-size: 20px; display: flex; align-items: center; justify-content: center;
            border-radius: 4px; cursor: pointer; flex-shrink: 0;
            box-shadow: 0 0 5px rgba(255,255,255,0.5);
            font-weight: bold; letter-spacing: 2px;
        }
        #pause-btn-center:active { background: #FFF; color: #000; }

        .stats-group { display: flex; flex-direction: row; gap: 10px; justify-content: center; width: 100%; }
        
        .hud-box { 
            background: rgba(20, 0, 40, 0.85); padding: 2px 8px; 
            border: 2px solid #00FFFF; border-radius: 4px;
            box-shadow: 0 0 5px #00FFFF; color: #FFF; font-size: 24px; 
            display: flex; flex-direction: column; align-items: center; min-width: 70px;
            text-shadow: 1px 1px 0 #b82e8a;
        }
        .hud-label { font-size: 14px; color: #FF00FF; text-transform: uppercase; letter-spacing: 1px; }

        #combo-wrapper { 
            position: absolute; bottom: 180px; right: 20px; 
            opacity: 0; transition: opacity 0.2s; pointer-events: none; 
            transform-origin: right center; scale: 0.8; top: auto; left: auto;
        }
        #combo-container { display: flex; flex-direction: column; align-items: flex-end; transition: all 0.3s; }
        .combo-count { font-size: 60px; color: #FFFF00; text-shadow: 3px 3px 0 #FF0000; line-height: 0.8; font-style: italic; font-weight: bold; }
        .combo-label { font-size: 24px; color: #FFA500; letter-spacing: 2px; text-shadow: 1px 1px 0 #000; }
        .combo-mult { font-size: 30px; color: #00FFFF; text-shadow: 1px 1px 0 #0000FF; margin-top: 2px; }
        .combo-bar-bg { width: 150px; height: 8px; background: rgba(0,0,0,0.5); border: 1px solid #FFF; margin-top: 2px; skew-x: -20deg; }
        #combo-timer-fill { height: 100%; width: 100%; background: linear-gradient(90deg, #FF8800, #FFFF00); transform-origin: left; transition: transform 0.1s linear; }
        
        .shake-anim { animation: shake 0.2s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake { 10%, 90% { transform: translate3d(-2px, -2px, 0); } 20%, 80% { transform: translate3d(4px, 4px, 0); } 30%, 50%, 70% { transform: translate3d(-6px, -2px, 0); } 40%, 60% { transform: translate3d(6px, 2px, 0); } }

        .combo-overdrive .combo-count { color: #FFD700 !important; text-shadow: 0 0 10px #FFD700, 3px 3px 0 #FF4500 !important; }
        .combo-overdrive .combo-label { color: #FFD700 !important; text-shadow: 0 0 5px #FFD700 !important; }
        .combo-overdrive .combo-mult { color: #FFF !important; text-shadow: 0 0 10px #FFD700 !important; }
        .combo-overdrive .combo-bar-bg { border-color: #FFD700; box-shadow: 0 0 10px #FFD700; }
        .combo-overdrive #combo-timer-fill { 
            background: linear-gradient(90deg, #FFD700, #FFFF00, #FFFFFF, #FFD700) !important; 
            background-size: 200% 100%;
            animation: shine 0.5s linear infinite; 
        }
        @keyframes shine { 0% { background-position: 100% 0; } 100% { background-position: -100% 0; } }

        #mobile-controls {
            position: absolute; bottom: 10px; left: 0; width: 100%; height: 160px;
            pointer-events: auto; z-index: 50;
            display: flex; justify-content: space-between; align-items: flex-end;
            padding: 0 20px;
            padding-bottom: env(safe-area-inset-bottom);
            box-sizing: border-box;
            touch-action: none; 
        }
        
        #joystick-zone { width: 140px; height: 140px; display: flex; align-items: center; justify-content: center; position: relative; }
        #joystick-base {
            width: 120px; height: 120px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            position: relative;
        }
        #joystick-stick {
            width: 50px; height: 50px; border-radius: 50%;
            background: radial-gradient(#00FFFF, #008888); border: 2px solid #FFF;
            box-shadow: 0 0 10px #00FFFF;
            position: absolute; 
            top: 50%; left: 50%; 
            margin-top: -25px; margin-left: -25px;
            transform: translate(0, 0);
            pointer-events: none;
        }

        #boost-zone { width: 120px; height: 140px; display: flex; align-items: center; justify-content: center; margin-right: 15px; }
        #boost-btn {
            width: 90px; height: 90px; border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #ff8800, #ff0000);
            border: 4px solid #FFFFFF;
            color: #FFF; display: flex; flex-direction: column; align-items: center; justify-content: center;
            font-size: 18px; font-weight: bold; text-shadow: 1px 1px 0 #000;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5), 0 0 15px #FF4500;
            transition: transform 0.1s;
        }
        #boost-btn:active { transform: scale(0.9); background: radial-gradient(circle at 30% 30%, #ffffff, #ff8800); color: #000; text-shadow: none; box-shadow: 0 0 25px #ffaa00; }
        #boost-btn span { font-size: 30px; line-height: 20px; display: block; margin-bottom: 2px; }

        #active-effects-container { position: absolute; top: 130px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; gap: 5px; width: 300px; pointer-events: none; }
        .effect-row { display: flex; flex-direction: column; background: rgba(0,0,0,0.7); border: 2px solid; padding: 3px; opacity: 1; transition: opacity 0.3s; }
        .effect-row.hidden { opacity: 0; }
        .effect-label { font-size: 18px; text-shadow: 1px 1px 0 #000; margin-bottom: 2px; text-align: center; letter-spacing: 1px;}
        .effect-bar-bg { width: 100%; height: 6px; background: rgba(255,255,255,0.1); }
        .effect-bar-fill { height: 100%; width: 100%; transform-origin: left; transition: transform 0.1s linear; }
        
        .style-rocket { border-color: #FF00FF; color: #FF00FF; }
        .style-rocket .effect-bar-fill { background: repeating-linear-gradient(45deg, #FF00FF, #FF00FF 10px, #FFFFFF 10px, #FFFFFF 20px); }
        .style-shield { border-color: #00FF00; color: #00FF00; }
        .style-shield .effect-bar-fill { background: #00FF00; }
        .style-drill { border-color: #FFFF00; color: #FFFF00; }
        .style-drill .effect-bar-fill { background: #FFFF00; }

        .overlay-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(20, 0, 30, 0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; transition: opacity 0.3s; }
        .btn { 
            background: #FF00FF; color: #FFF; border: 4px solid #FFF; padding: 15px 40px; 
            font-size: 30px; font-family: 'VT323', monospace; cursor: pointer; 
            box-shadow: 0 0 15px #FF00FF; transition: transform 0.1s; margin: 10px;
            text-shadow: 2px 2px 0 #000; outline: none; -webkit-tap-highlight-color: transparent;
        }
        .btn:active { transform: scale(0.95); background: #FFF; color: #FF00FF; }
        .btn-small { padding: 8px 15px; font-size: 20px; background: #00FFFF; box-shadow: 0 0 15px #00FFFF; color: #000; border-color: #000; width: 130px;}
        .menu-row { display: flex; gap: 10px; justify-content: center; width: 100%; max-width: 400px; flex-wrap: wrap; }

        .leaderboard-container { background: rgba(0,0,0,0.4); padding: 15px; border: 4px solid #00FFFF; margin-bottom: 20px; width: 300px; color: white; text-align: center; font-size: 20px; box-shadow: 0 0 10px #00FFFF;}
        .score-entry { display: flex; justify-content: space-between; border-bottom: 1px dashed #FF00FF; margin: 5px 0; color: #00FFFF; }
        #highscore-form { display: flex; flex-direction: column; align-items: center; gap: 10px; margin-bottom: 20px; background: rgba(0, 50, 0, 0.6); padding: 15px; border: 2px solid #00FF00; }
        #player-name-input { background: #000; color: #00FF00; border: 2px solid #00FF00; font-family: 'VT323', monospace; font-size: 30px; text-align: center; width: 200px; padding: 5px; text-transform: uppercase; }
        
        .audio-settings-box { background: rgba(0,0,0,0.9); border: 4px solid #FF00FF; padding: 20px; width: 90%; max-width: 400px; color: white; text-align: center; box-shadow: 0 0 20px #FF00FF; }
        .slider-group { margin: 15px 0; text-align: left; }
        .slider-label { display: flex; justify-content: space-between; color: #00FFFF; font-size: 20px; margin-bottom: 5px; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #FF00FF; height: 20px; }

        .guide-box { 
            background: rgba(10, 0, 20, 0.95); border: 4px solid #00FFFF; 
            padding: 10px; width: 90%; max-width: 500px; height: 70%;
            color: white; display: flex; flex-direction: column;
            box-shadow: 0 0 20px #00FFFF, inset 0 0 30px rgba(0,255,255,0.2);
            position: relative;
        }
        .guide-content { flex: 1; overflow-y: auto; padding-right: 10px; text-align: left; }
        .guide-section { margin-bottom: 20px; border-bottom: 2px solid #FF00FF; padding-bottom: 10px; }
        .guide-title { color: #FF00FF; font-size: 28px; margin-bottom: 10px; text-shadow: 2px 2px 0 #000; letter-spacing: 2px;}
        .guide-item { display: flex; align-items: center; margin-bottom: 10px; background: rgba(255,255,255,0.05); padding: 5px; border-radius: 4px; }
        .guide-icon { width: 40px; height: 40px; margin-right: 15px; border: 2px solid white; flex-shrink: 0; display: flex; align-items: center; justify-content: center; font-size: 20px; text-shadow: 1px 1px 0 #000; box-shadow: 0 0 5px currentColor; }
        .guide-desc { flex: 1; font-size: 18px; color: #DDD; line-height: 1.1; }
        .guide-desc strong { color: #00FFFF; display: block; font-size: 20px; margin-bottom: 2px; }
        
        .icon-fuel { background: #FF0000; color: #FF0000; box-shadow: 0 0 8px #FF0000;}
        .icon-wrench { background: #C0C0C0; color: #C0C0C0; box-shadow: 0 0 8px #C0C0C0;}
        .icon-score { background: #FFFFFF; color: #FFFFFF; box-shadow: 0 0 8px #FFFFFF;}
        .icon-rocket { background: repeating-linear-gradient(45deg, #FF00FF, #FF00FF 5px, #FFF 5px, #FFF 10px); color: #FF00FF; border-color: #FF00FF;}
        .icon-shield { background: #00FFFF; color: #00FFFF; box-shadow: 0 0 10px #00FFFF; }
        .icon-drill { background: #FFFF00; color: #FFFF00; box-shadow: 0 0 10px #FFFF00; }
        .icon-bird { background: #4A4A4A; border-color: #B87333; }
        .icon-balloon { background: #8B4513; border-color: #F5DEB3; }
        .icon-ufo { background: #333333; border-color: #00FF00; color: #FF0000; }

        #damage-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 40%, rgba(255,0,0,0.6) 100%); opacity: 0; pointer-events: none; transition: opacity 0.1s; z-index: 50; }
        #heal-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 40%, rgba(0,255,0,0.4) 100%); opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 50; }
        #speed-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 50%, rgba(255, 0, 255, 0.2) 80%, rgba(255, 255, 255, 0.4) 100%); opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 40; mix-blend-mode: hard-light; }
        #shield-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 50%, rgba(0, 255, 0, 0.2) 100%); opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 40; mix-blend-mode: screen; }

        .hidden { display: none !important; }
        h1 { font-size: 70px; color: #FF00FF; text-shadow: 4px 4px 0 #00FFFF; margin: 0; line-height: 0.9; text-align: center; font-style: italic; }
        h1 span { display: block; font-size: 35px; color: #FFFF00; text-shadow: 2px 2px 0 #FF0000; transform: rotate(-2deg); margin-top: 5px; font-style: normal;}
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
</head>
<body>
    <div id="background-gradient"></div>
    <div id="overdrive-overlay"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="status-bars">
                <!-- Health Bar -->
                <div class="bar-wrapper" id="health-wrapper">
                    <div class="bar-icon-box">✚</div>
                    <div class="bar-fill-container"><div class="bar-fill" id="health-fill"></div></div>
                </div>
                
                <!-- PAUSE BTN CENTER -->
                <div id="pause-btn-center" onclick="togglePause()">||</div>

                <!-- Energy Bar -->
                <div class="bar-wrapper" id="energy-wrapper">
                    <div class="bar-icon-box">⚡</div>
                    <div class="bar-fill-container"><div class="bar-fill" id="energy-fill"></div></div>
                </div>
            </div>
            
            <div class="stats-group">
                <div class="hud-box"><span class="hud-label">Score</span><span id="score-display">0</span></div>
                <div class="hud-box"><span class="hud-label">Distance</span><span id="dist-display">0 m</span></div>
            </div>
        </div>
        
        <div id="combo-wrapper">
            <div id="combo-container">
                <div class="combo-label" id="combo-label-text">COMBO !</div>
                <div class="combo-count" id="combo-count-val">x0</div>
                <div class="combo-mult" id="combo-mult-val">BONUS x1.0</div>
                <div class="combo-bar-bg"><div id="combo-timer-fill"></div></div>
            </div>
        </div>

        <div id="active-effects-container">
            <div id="effect-rocket" class="effect-row style-rocket hidden">
                <div class="effect-label">HYPER VITESSE</div>
                <div class="effect-bar-bg"><div class="effect-bar-fill" id="fill-rocket"></div></div>
            </div>
            <div id="effect-shield" class="effect-row style-shield hidden">
                <div class="effect-label">BOUCLIER ANTI-OISEAUX</div>
                <div class="effect-bar-bg"><div class="effect-bar-fill" id="fill-shield"></div></div>
            </div>
            <div id="effect-drill" class="effect-row style-drill hidden">
                <div class="effect-label">VRILLE FORAGE</div>
                <div class="effect-bar-bg"><div class="effect-bar-fill" id="fill-drill"></div></div>
            </div>
        </div>

        <div id="mobile-controls" class="hidden">
            <div id="joystick-zone">
                <div id="joystick-base">
                    <div id="joystick-stick"></div>
                </div>
            </div>
            <div id="boost-zone">
                <div id="boost-btn"><span>▲</span>BOOST</div>
            </div>
        </div>

    </div>
    <div id="damage-overlay"></div><div id="heal-overlay"></div><div id="speed-overlay"></div><div id="shield-overlay"></div>

    <div id="start-screen" class="overlay-screen">
        <h1>PLANE RUSH<span>Mobile</span></h1>
        <div class="leaderboard-container"><div style="color:#FFFF00; margin-bottom:10px;">MEILLEURS PILOTES</div><div id="lb-start"></div></div>
        
        <div class="menu-row">
            <button class="btn btn-small" onclick="AudioSys.unlock(); openGuide()">GUIDE</button>
            <button class="btn btn-small" onclick="AudioSys.unlock(); openAudioSettings()">PARAMETRES</button>
        </div>

        <p style="color:#00FFFF; font-size: 20px; text-shadow: 2px 2px 0 #FF00FF; margin: 15px 0;">PRET AU DECOLLAGE ?</p>
        <button class="btn" onclick="startGame()">JOUER</button>
    </div>

    <div id="guide-screen" class="overlay-screen hidden">
        <div class="guide-box">
            <h2 style="color:#00FFFF; text-align:center; margin: 0 0 15px 0; border-bottom: 2px solid white; padding-bottom: 5px;">MANUEL DE VOL</h2>
            <div class="guide-content">
                <div class="guide-section">
                    <div class="guide-title">RAVITAILLEMENT</div>
                    <div class="guide-item"><div class="guide-icon icon-fuel"></div><div class="guide-desc"><strong>CARBURANT (Rouge)</strong>Recharge 50% d'énergie.</div></div>
                    <div class="guide-item"><div class="guide-icon icon-wrench"></div><div class="guide-desc"><strong>RÉPARATION (Gris)</strong>Répare 100% de la structure.</div></div>
                    <div class="guide-item"><div class="guide-icon icon-score"></div><div class="guide-desc"><strong>BONUS & OVERDRIVE</strong>Tuez 3+ ennemis pour l'Overdrive (Régène 95% boost!).</div></div>
                </div>
                <div class="guide-section">
                    <div class="guide-title">POWER-UPS</div>
                    <div class="guide-item"><div class="guide-icon icon-rocket"></div><div class="guide-desc"><strong>FUSÉE (Rose)</strong>Hyper Vitesse et invincibilité.</div></div>
                    <div class="guide-item"><div class="guide-icon icon-shield"></div><div class="guide-desc"><strong>BOUCLIER (Cyan)</strong>Absorbe 1 collision.</div></div>
                    <div class="guide-item"><div class="guide-icon icon-drill"></div><div class="guide-desc"><strong>VRILLE (Jaune)</strong>Détruit les obstacles.</div></div>
                </div>
                <div class="guide-section">
                    <div class="guide-title">DANGERS</div>
                    <div class="guide-item"><div class="guide-icon icon-bird"></div><div class="guide-desc"><strong>OISEAUX MÉCANIQUES</strong>Dégâts légers (25). Contré par le Bouclier.</div></div>
                    <div class="guide-item"><div class="guide-icon icon-balloon"></div><div class="guide-desc"><strong>BALLONS MINES</strong>Dégâts lourds (50). Contré par la Vrille.</div></div>
                    <div class="guide-item"><div class="guide-icon icon-ufo">UFO</div><div class="guide-desc"><strong>LASER ALIEN</strong>Rayon vertical rouge (Dégâts 50). Apparaît après 1500m. ESQUIVEZ !</div></div>
                </div>
            </div>
            <button class="btn" style="margin: 10px auto 0 auto; font-size: 24px; padding: 5px 30px;" onclick="closeGuide()">RETOUR</button>
        </div>
    </div>

    <div id="audio-screen" class="overlay-screen hidden">
        <div class="audio-settings-box">
            <h2 style="color:#00FFFF; margin-bottom: 20px;">PARAMETRES</h2>
            <div class="slider-group"><div class="slider-label"><span>QUALITÉ</span> <span id="res-val">AUTO</span></div><input type="range" min="50" max="300" value="0" id="res-slider" oninput="updateResolution(this.value)"></div>
            <div class="slider-group"><div class="slider-label"><span>MUSIQUE</span> <span id="vol-music-val">40%</span></div><input type="range" min="0" max="100" value="40" oninput="updateAudioSettings('music', this.value)"></div>
            <div class="slider-group"><div class="slider-label"><span>MOTEUR</span> <span id="vol-engine-val">30%</span></div><input type="range" min="0" max="100" value="30" oninput="updateAudioSettings('engine', this.value)"></div>
            <div class="slider-group"><div class="slider-label"><span>EFFETS</span> <span id="vol-sfx-val">50%</span></div><input type="range" min="0" max="100" value="50" oninput="updateAudioSettings('sfx', this.value)"></div>
            <button class="btn" onclick="closeAudioSettings()">RETOUR</button>
        </div>
    </div>
    
    <div id="pause-screen" class="overlay-screen hidden">
        <h1>PAUSE</h1>
        <button class="btn" onclick="togglePause()">REPRENDRE</button>
        <button class="btn btn-small" onclick="quitToMenu()" style="margin-top:20px; background:#cc3333; color:#fff; border-color:#fff;">QUITTER</button>
    </div>
    
    <div id="game-over-screen" class="overlay-screen hidden">
        <h1 style="color:#ff3333; text-shadow: 4px 4px 0 #3e2723;">CRASH!</h1>
        <div class="hud-box" style="align-items: center; margin: 10px 0;">
            <span class="hud-label">Rapport Final</span>
            <span id="final-score">Score: 0</span>
            <span id="final-dist" style="font-size:25px; color:#aaa">Dist: 0m</span>
        </div>
        <div id="highscore-form" class="hidden">
            <div style="color:#00FF00; font-size:24px; text-align:center;">NOUVEAU RECORD !<br>Nom :</div>
            <input type="text" id="player-name-input" maxlength="8" placeholder="PILOTE">
            <button class="btn btn-small" onclick="submitHighScore()" style="background:#00FF00; color:#000; border-color:#005500;">VALIDER</button>
        </div>
        <div class="leaderboard-container"><div style="color:#FFD700; margin-bottom:10px;">TOP 5</div><div id="lb-end"></div></div>
        <button class="btn" onclick="resetGame()">RÉESSAYER</button>
    </div>

    <script>
        const VOLUMES = { music: 0.4, engine: 0.3, sfx: 0.5 };
        let renderScale = 0; 
        const clock = new THREE.Clock(); 

        const PARTICLE_GEO = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        const PARTICLE_MAT_BASE = new THREE.MeshBasicMaterial();

        const AudioSys = { 
            ctx: null, engineOsc: null, engineGain: null, bgMusic: null, menuMusic: null,
            init: function() { 
                if(!this.ctx) { 
                    this.ctx = new (window.AudioContext||window.webkitAudioContext)(); 
                    this.engineOsc = this.ctx.createOscillator(); this.engineGain = this.ctx.createGain(); 
                    this.engineOsc.type = 'sawtooth'; this.engineOsc.frequency.value = 60; this.engineGain.gain.value = 0; 
                    this.engineOsc.connect(this.engineGain); this.engineGain.connect(this.ctx.destination); this.engineOsc.start(); 
                    this.bgMusic = new Audio('music.mp3'); this.bgMusic.loop = true; this.bgMusic.volume = VOLUMES.music;
                    this.menuMusic = new Audio('main_menu_music.mp3'); this.menuMusic.loop = true; this.menuMusic.volume = VOLUMES.music;
                } 
            },
            unlock: function() {
                if(!this.ctx) this.init();
                if(this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
                if(this.menuMusic && this.menuMusic.paused && (!this.bgMusic || this.bgMusic.paused)) {
                    this.menuMusic.play().catch(e=>{});
                }
            },
            updateEngine: function(ratio, volMult = 1.0) { 
                if(!this.engineOsc) return; 
                this.engineOsc.frequency.setTargetAtTime(60 + (ratio * 100), this.ctx.currentTime, 0.1); 
                const dynamicVol = 0.05 + (ratio * 0.05);
                this.engineGain.gain.setTargetAtTime(dynamicVol * (VOLUMES.engine * 2) * volMult, this.ctx.currentTime, 0.1); 
            },
            play: function(f,t,d,v=0.1) { 
                if(!this.ctx)return; const o=this.ctx.createOscillator(),g=this.ctx.createGain(); o.type=t; o.frequency.value=f; 
                g.gain.setValueAtTime(v * VOLUMES.sfx, this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.01,this.ctx.currentTime+d); 
                o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(this.ctx.currentTime+d); 
            }, 
            coin:()=>AudioSys.play(600,'square',0.1), hit:()=>AudioSys.play(100,'sawtooth',0.3, 0.3), boost:()=>AudioSys.play(300,'square',0.5,0.1), 
            smash:()=>AudioSys.play(50,'square',0.2,0.5), heal:()=>AudioSys.play(600,'sine',0.5,0.2), fuel:()=>AudioSys.play(200,'sawtooth',0.3,0.1), 
            drill:()=>AudioSys.play(80,'square',0.3,0.2), 
            startMenuMusic: () => {
                AudioSys.unlock();
                if(AudioSys.bgMusic) { AudioSys.bgMusic.pause(); AudioSys.bgMusic.currentTime = 0; }
                if(AudioSys.menuMusic && AudioSys.menuMusic.paused) { 
                    AudioSys.menuMusic.volume = VOLUMES.music; AudioSys.menuMusic.play().catch(e=>{}); 
                }
            },
            startGameMusic: () => {
                AudioSys.unlock();
                if(AudioSys.menuMusic) { AudioSys.menuMusic.pause(); AudioSys.menuMusic.currentTime = 0; }
                if(AudioSys.bgMusic) { 
                    AudioSys.bgMusic.volume = VOLUMES.music; 
                    AudioSys.bgMusic.currentTime = 0; 
                    AudioSys.bgMusic.play().catch(e => {}); 
                }
            },
            gameOver:()=>{ 
                AudioSys.play(60,'sawtooth',1.0, 0.5); 
                if(AudioSys.engineGain) AudioSys.engineGain.gain.setTargetAtTime(0, AudioSys.ctx.currentTime, 0.1); 
                if(AudioSys.bgMusic) { AudioSys.bgMusic.pause(); }
            },
            pauseMusic: (p) => { if(AudioSys.bgMusic) { p ? AudioSys.bgMusic.pause() : AudioSys.bgMusic.play(); } },
            updateMusicVolume: () => { if(AudioSys.bgMusic) AudioSys.bgMusic.volume = VOLUMES.music; if(AudioSys.menuMusic) AudioSys.menuMusic.volume = VOLUMES.music; }
        };

        window.addEventListener('touchstart', () => AudioSys.unlock(), {once:true});
        window.addEventListener('click', () => AudioSys.unlock(), {once:true});

        function switchScreen(id) {
            document.querySelectorAll('.overlay-screen').forEach(s => s.classList.add('hidden'));
            document.getElementById(id).classList.remove('hidden');
        }

        function openGuide() { switchScreen('guide-screen'); }
        function closeGuide() { switchScreen('start-screen'); }

        function openAudioSettings() { 
            switchScreen('audio-screen'); 
            const slider = document.getElementById('res-slider');
            if(renderScale === 0) {
                slider.value = 0;
                document.getElementById('res-val').innerText = "AUTO (" + window.devicePixelRatio.toFixed(1) + "x)";
            } else {
                slider.value = renderScale * 100;
                document.getElementById('res-val').innerText = renderScale.toFixed(1) + "x";
            }
        }
        function closeAudioSettings() { switchScreen('start-screen'); }
        function updateAudioSettings(type, val) {
            const pct = parseInt(val); const decimal = pct / 100;
            if(type === 'music') { VOLUMES.music = decimal; document.getElementById('vol-music-val').innerText = pct + '%'; AudioSys.updateMusicVolume(); } 
            else if (type === 'engine') { VOLUMES.engine = decimal; document.getElementById('vol-engine-val').innerText = pct + '%'; } 
            else if (type === 'sfx') { VOLUMES.sfx = decimal; document.getElementById('vol-sfx-val').innerText = pct + '%'; }
        }
        function updateResolution(val) {
            if(val == 0 || val < 50) {
                renderScale = 0;
                document.getElementById('res-val').innerText = "AUTO";
            } else {
                renderScale = val / 100;
                document.getElementById('res-val').innerText = renderScale.toFixed(1) + "x";
            }
            if(renderer) {
                const ratio = renderScale === 0 ? Math.min(window.devicePixelRatio, 3) : renderScale;
                renderer.setPixelRatio(ratio);
            }
        }

        const CONFIG = { 
            baseSpeed: 1.8, maxBoostSpeed: 4.5, 
            chunkSize: 100, chunkCount: 30, 
            colors: {
                birdBody: 0x4A4A4A, birdWing: 0xB87333, 
                cloud: 0xFFFFFF, rocket: 0xFF00FF, wrench: 0xC0C0C0, 
                fuel: 0xFF0000, missile: 0x00FFFF, 
                drill: 0x607D8B, 
                terrainBase: 0xA0522D, terrainVar1: 0xF4A460, terrainVar2: 0xD2B48C, 
                balloonMain: 0x8B4513, balloonSec: 0xF5DEB3,   
                planeMain: 0xD32F2F, planeSec: 0xFFFFFF,
                ufoMain: 0x333333, ufoLight: 0x00FF00, alienLaser: 0xFF0000
            }
        };
        
        let scene, camera, renderer, plane, propeller, sunMesh, drillMesh, starField;
        let terrainChunks = [], objects = [], particles = [];
        let score = 0, health = 100, energy = 50, gameSpeed = CONFIG.baseSpeed, distance = 0;
        let isPlaying = false, isPaused = false, frameCount = 0;
        let mouseX = 0, mouseY = 0; 
        let joystickInput = { x: 0, y: 0 };
        let isBoosting = false;
        let invincibleTimer = 0; const INVINCIBLE_DURATION = 400; 
        let birdShieldTimer = 0; const BIRD_SHIELD_DURATION = 600; 
        let drillTimer = 0; const DRILL_DURATION = 600;
        let comboCount = 0; let comboTimer = 0; let currentComboMultiplier = 1.0;
        const COMBO_WINDOW = 600; 
        let bounceForce = 0, wallHitTimer = 0, isInputLocked = false;
        let screenShake = 0, isIntro = false, introTimer = 0;
        const INTRO_DURATION_MS = 3000; 
        let introStartTime = 0;
        
        let simplex;

        function getScores() { const s = localStorage.getItem('planeRushFinalScores'); let scores = s ? JSON.parse(s) : []; return scores.map(sc => { if(!sc.name) sc.name = "ANONYME"; return sc; }); }
        function saveScore(name, ns, dist) { let s = getScores(); s.push({name: name.toUpperCase(), score: ns, dist: dist}); s.sort((a,b) => b.score - a.score); s = s.slice(0,5); localStorage.setItem('planeRushFinalScores', JSON.stringify(s)); return s; }
        function isHighScore(ns) { let s = getScores(); if (s.length < 5) return true; return ns > s[s.length-1].score; }
        function updateLeaderboardUI() { const s = getScores(); while(s.length < 5) s.push({name: "---", score:0, dist:0}); const html = s.map((v,i) => `<div class="score-entry"><span>#${i+1} ${v.name}</span><span>${v.score}</span></div>`).join(''); document.getElementById('lb-start').innerHTML = html; document.getElementById('lb-end').innerHTML = html; }
        function submitHighScore() { let name = document.getElementById('player-name-input').value; if(!name || name.trim() === "") name = "PILOTE"; saveScore(name, score, distance); updateLeaderboardUI(); document.getElementById('highscore-form').classList.add('hidden'); }

        function getDifficultyMultiplier() { return 1 + (distance / 2000); }
        
        function getTerrainHeight(x, z) {
            if(!simplex) return -12;
            let noise = simplex.noise2D(x * 0.02, z * 0.02); let h = -12; 
            if(Math.abs(x) > 30) { let canyonH = Math.max(0, noise * 40 + (Math.abs(x) - 30) * 1.5); h += Math.floor(canyonH / 4) * 4; }
            if (z < -300) {
                let spikeNoise = simplex.noise2D(x * 0.08, z * 0.08); 
                if (spikeNoise > 0.82 && Math.abs(x) < 25) { 
                    // CHANGED: Increased spike height to 115
                    let spikeH = (spikeNoise - 0.82) * 115; 
                    h += Math.floor(spikeH / 4) * 4; 
                }
            }
            return h;
        }

        function init() {
            AudioSys.init(); 
            // Initialize SimplexNoise safely
            if(typeof SimplexNoise !== 'undefined') simplex = new SimplexNoise();

            updateLeaderboardUI();
            switchScreen('start-screen'); 

            scene = new THREE.Scene(); 
            scene.fog = new THREE.Fog(0xffbd55, 600, 2500); 
            
            let camZ = 32;
            if(window.innerHeight > window.innerWidth) camZ = 45; 
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 3000); 
            camera.position.set(0, 8, 25);
            
            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true }); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
            const ratio = renderScale === 0 ? Math.min(window.devicePixelRatio, 3) : renderScale;
            renderer.setPixelRatio(ratio);
            renderer.shadowMap.enabled = true; 
            renderer.shadowMap.type = THREE.BasicShadowMap; 
            document.body.appendChild(renderer.domElement);

            const sunLight = new THREE.DirectionalLight(0xffeba1, 1.2); sunLight.position.set(50, 80, 50); sunLight.castShadow = true; sunLight.shadow.mapSize.width = 1024; sunLight.shadow.mapSize.height = 1024; sunLight.shadow.camera.left = -100; sunLight.shadow.camera.right = 100; scene.add(sunLight); 
            const ambient = new THREE.AmbientLight(0xffaf7b, 0.6); scene.add(ambient);
            const sunGeo = new THREE.CircleGeometry(60, 32); const sunMat = new THREE.MeshBasicMaterial({ color: 0xFFFF00 }); sunMesh = new THREE.Mesh(sunGeo, sunMat); scene.add(sunMesh);
            
            createVoxelPlane();
            createStarField();

            for(let i=0; i<CONFIG.chunkCount; i++) terrainChunks.push(createChunk(-i * CONFIG.chunkSize));
            
            setupMobileControls();
            
            window.addEventListener('resize', () => { 
                camera.aspect = window.innerWidth/window.innerHeight; 
                if(window.innerHeight > window.innerWidth) camera.position.z = 45; else camera.position.z = 25;
                camera.updateProjectionMatrix(); 
                renderer.setSize(window.innerWidth, window.innerHeight); 
            });
            
            AudioSys.startMenuMusic();
            animate();
        }

        function setupMobileControls() {
            const stick = document.getElementById('joystick-stick');
            const zone = document.getElementById('joystick-zone');
            const base = document.getElementById('joystick-base');
            const boost = document.getElementById('boost-btn');
            
            let stickId = null;
            const maxRadius = 40;

            const updateStick = (clientX, clientY) => {
                const rect = base.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let dx = clientX - centerX;
                let dy = clientY - centerY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist > maxRadius) {
                    const ratio = maxRadius / dist;
                    dx *= ratio; dy *= ratio;
                }
                
                stick.style.transform = `translate(${dx}px, ${dy}px)`;
                
                // Normal X
                joystickInput.x = dx / maxRadius;
                // Inverted Y (Screen Y down = positive, Game Y up = positive)
                joystickInput.y = -(dy / maxRadius);
            };

            const handleTouchStart = (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                stickId = touch.identifier;
                updateStick(touch.clientX, touch.clientY);
            };

            const handleTouchMove = (e) => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++){
                    if(e.changedTouches[i].identifier === stickId) {
                        updateStick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                        break;
                    }
                }
            };

            const handleTouchEnd = (e) => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++){
                    if(e.changedTouches[i].identifier === stickId) {
                        stickId = null;
                        stick.style.transform = `translate(0px, 0px)`;
                        joystickInput.x = 0; joystickInput.y = 0;
                        break;
                    }
                }
            };

            zone.addEventListener('touchstart', handleTouchStart, {passive: false});
            zone.addEventListener('touchmove', handleTouchMove, {passive: false});
            zone.addEventListener('touchend', handleTouchEnd, {passive: false});
            
            // Boost listeners
            boost.addEventListener('touchstart', e => { e.preventDefault(); isBoosting = true; }, {passive: false});
            boost.addEventListener('touchend', e => { e.preventDefault(); isBoosting = false; }, {passive: false});
        }

        function createStarField() {
            const starGeo = new THREE.BufferGeometry();
            const starCount = 1000;
            const posArray = new Float32Array(starCount * 3);
            for(let i=0; i<starCount*3; i+=3) {
                posArray[i] = (Math.random() - 0.5) * 600; 
                posArray[i+1] = Math.random() * 200 + 40; 
                posArray[i+2] = (Math.random() - 0.5) * 1000 - 200;
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const starMat = new THREE.PointsMaterial({color: 0xFFFFFF, size: 0.6, transparent: true, opacity: 0.7});
            starField = new THREE.Points(starGeo, starMat);
            scene.add(starField);
        }

        function createVoxelBox(w, h, d, color, x, y, z, emissive=false, opacity=1.0) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshPhongMaterial({
                color: color, 
                flatShading: true, 
                emissive: emissive ? color : 0x000000, 
                emissiveIntensity: emissive ? 0.5 : 0,
                transparent: opacity < 1.0,
                opacity: opacity
            });
            const mesh = new THREE.Mesh(geo, mat); mesh.position.set(x, y, z); mesh.castShadow = true; mesh.receiveShadow = true;
            
            const edges = new THREE.EdgesGeometry(geo);
            const lineMat = new THREE.LineBasicMaterial({ 
                color: 0x000000, 
                opacity: 1.0, 
                transparent: false
            });
            if(opacity < 1.0) { lineMat.transparent = true; lineMat.opacity = 0.5; }

            const line = new THREE.LineSegments(edges, lineMat);
            mesh.add(line);
            return mesh;
        }

        function createVoxelPlane() {
            plane = new THREE.Group();
            const P_OPACITY = 0.9; 
            
            plane.add(createVoxelBox(2, 2, 6, 0xD32F2F, 0, 0, 0, false, P_OPACITY)); 
            const glassGeo = new THREE.BoxGeometry(1.8, 0.8, 1.5);
            const glassMat = new THREE.MeshPhongMaterial({color: 0x88CCFF, transparent: true, opacity: 0.6, flatShading: true});
            const glass = new THREE.Mesh(glassGeo, glassMat); glass.position.set(0, 1.2, 0.5);
            plane.add(glass);

            plane.add(createVoxelBox(10, 0.5, 3, 0xFFFFFF, 0, 1.5, 0, false, P_OPACITY)); 
            plane.add(createVoxelBox(8, 0.5, 3, 0xFFFFFF, 0, -1, 0, false, P_OPACITY));
            plane.add(createVoxelBox(10.1, 0.1, 0.2, 0x00FFFF, 0, 1.51, 1.5, true, P_OPACITY)); 
            plane.add(createVoxelBox(8.1, 0.1, 0.2, 0x00FFFF, 0, -1.01, 1.5, true, P_OPACITY));

            plane.add(createVoxelBox(4, 0.5, 2, 0xFFFFFF, 0, 0.5, 2.5, false, P_OPACITY)); 
            plane.add(createVoxelBox(0.5, 2.5, 2.1, 0xD32F2F, 0, 1.1, 2.5, false, P_OPACITY)); 
            plane.add(createVoxelBox(0.1, 2.6, 0.2, 0x00FFFF, 0, 1.11, 3.5, true, P_OPACITY));

            plane.add(createVoxelBox(0.2, 2.5, 0.5, 0x333333, -3, 0, 0, false, P_OPACITY)); 
            plane.add(createVoxelBox(0.2, 2.5, 0.5, 0x333333, 3, 0, 0, false, P_OPACITY));
            
            propeller = createVoxelBox(6, 0.5, 0.5, 0x333333, 0, 0, -3.2, false, P_OPACITY); plane.add(propeller);
            
            drillMesh = new THREE.Group();
            drillMesh.add(createVoxelBox(2.0, 3.0, 2.0, 0x555555, 0, 0, 0, false, P_OPACITY)); 
            drillMesh.add(createVoxelBox(2.5, 0.8, 2.5, 0xFFFF00, 0, 0.5, 0, true, P_OPACITY)); 
            drillMesh.add(createVoxelBox(1.5, 1.5, 1.5, 0xFFFFFF, 0, 1.8, 0, true, P_OPACITY)); 
            drillMesh.rotation.x = Math.PI / 2; drillMesh.position.set(0, 0, -6.0); 
            drillMesh.visible = false;
            plane.add(drillMesh); scene.add(plane);
        }

        function createChunk(zPos) {
            const geo = new THREE.PlaneGeometry(200, CONFIG.chunkSize, 50, 25); geo.rotateX(-Math.PI/2);
            const pos = geo.attributes.position; const colors = [];
            for(let i=0; i<pos.count; i++) {
                let x = pos.getX(i); let zGlobal = zPos + pos.getZ(i); let rawH = getTerrainHeight(x, zGlobal);
                pos.setY(i, Math.floor(rawH / 2) * 2);
                let c = new THREE.Color(CONFIG.colors.terrainBase); 
                if (rawH > -8) c.setHex(CONFIG.colors.terrainVar2); 
                if (rawH > -4) c.setHex(CONFIG.colors.terrainVar1); 
                colors.push(c.r, c.g, c.b);
            }
            geo.computeVertexNormals(); geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const mat = new THREE.MeshPhongMaterial({vertexColors: true, flatShading:true, shininess:0});
            const m = new THREE.Mesh(geo, mat); m.position.z = zPos; m.receiveShadow = true; 
            const edges = new THREE.EdgesGeometry(geo, 15); const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
            m.add(line); scene.add(m); return m;
        }

        function addGlow(group, colorHex) {
            const geo = new THREE.BoxGeometry(2.5, 2.5, 2.5);
            const mat = new THREE.MeshBasicMaterial({ color: colorHex, transparent: true, opacity: 0.4, wireframe: true });
            const aura = new THREE.Mesh(geo, mat);
            group.add(aura);
        }

        function createVoxelCloud() {
            const group = new THREE.Group();
            const col = CONFIG.colors.cloud;
            const width = 4 + Math.floor(Math.random() * 3); 
            const depth = 3 + Math.floor(Math.random() * 2);
            group.add(createVoxelBox(width, 1, depth, col, 0, 0, 0));
            const midW = width - 1 - Math.random(); 
            const midD = depth - 0.5;
            group.add(createVoxelBox(midW, 1, midD, col, 0, 1, 0));
            if (Math.random() > 0.3) {
                const topW = midW - 1.5;
                const topD = midD - 1;
                if(topW > 0.5) group.add(createVoxelBox(topW, 1, topD, col, 0, 2, 0));
            }
            return group;
        }

        function createAlienLaserUnit() {
            const group = new THREE.Group();
            // The Ship Body (High up)
            group.add(createVoxelBox(6, 2, 6, CONFIG.colors.ufoMain, 0, 0, 0));
            group.add(createVoxelBox(4, 1, 4, CONFIG.colors.ufoLight, 0, 1.5, 0, true));
            
            // The Laser Beam (Going down)
            // Height 200, Width 15, Depth 15
            // Positioned so the top is at the ship (y=0 relative to group) and extends down
            const beamGeo = new THREE.BoxGeometry(15, 200, 15);
            const beamMat = new THREE.MeshBasicMaterial({
                color: CONFIG.colors.alienLaser, 
                transparent: true, 
                opacity: 0.6
            });
            const beam = new THREE.Mesh(beamGeo, beamMat);
            beam.position.set(0, -100, 0); // Shift down by half height
            beam.userData = { isBeam: true }; // Tag for animation
            group.add(beam);
            
            // Inner Core for visual flair
            const coreGeo = new THREE.BoxGeometry(5, 200, 5);
            const coreMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.8 });
            const core = new THREE.Mesh(coreGeo, coreMat);
            core.position.set(0, -100, 0);
            group.add(core);

            return group;
        }

        function spawnObject() {
            if (isIntro) return; 
            const r = Math.random();
            let type = 'cloud';
            
            // NEW LOGIC: Alien Laser priority spawn
            if (distance > 1500 && Math.random() < 0.15) {
                const m = createAlienLaserUnit();
                // Spawn high up, X between -33 and 33
                const spawnZ = plane.position.z - 400;
                let spawnX = (Math.random()-0.5) * 66; // -33 to 33
                
                m.position.set(spawnX, 50, spawnZ); 
                m.userData = { type: 'alien_laser', baseScale: 1.0 };
                scene.add(m); objects.push(m);
                return; // Skip other spawns
            }

            // EXISTING LOGIC
            if(r < 0.30) type = 'bird'; // 30%
            else if(r < 0.52) type = 'balloon'; // 22%
            else if(r < 0.57) type = 'wrench';
            else if(r < 0.62) type = 'fuel';
            else if(r < 0.67) type = 'rocket';
            else if(r < 0.72) type = 'missile';
            else if(r < 0.77) type = 'drill';
            else type = 'cloud'; 

            let m;
            let baseScale = 1.3; 

            if(type === 'cloud') {
                m = createVoxelCloud();
                baseScale = 1.0 + Math.random() * 0.5; 
                m.userData = {type:'cloud', baseScale: baseScale, id: Math.random() * 100};
            }
            else {
                m = new THREE.Group();
                if(type==='bird') { 
                    const body = createVoxelBox(1.5, 1.5, 2.0, CONFIG.colors.birdBody, 0, 0, 0); 
                    const beak = createVoxelBox(0.5, 0.5, 0.8, 0xD4AF37, 0, 0, -1.2); 
                    const g1=new THREE.Group(); g1.add(createVoxelBox(2.5,0.2,1.5,CONFIG.colors.birdWing,-1.2,0,0)); g1.position.set(-0.5,0.2,0);
                    const g2=new THREE.Group(); g2.add(createVoxelBox(2.5,0.2,1.5,CONFIG.colors.birdWing,1.2,0,0)); g2.position.set(0.5,0.2,0);
                    m.add(body, beak, g1, g2); m.userData = {wings:[g1, g2], dead: false};
                    baseScale = 1.0;
                } 
                else if(type==='fuel') {
                    m.add(createVoxelBox(1.5, 2, 1.5, CONFIG.colors.fuel, 0, 0, 0)); m.add(createVoxelBox(0.2, 0.5, 1, 0x333333, 0, 1.2, 0)); 
                    addGlow(m, 0xFF0000);
                }
                else if(type==='missile') { 
                    const shGroup = new THREE.Group();
                    shGroup.add(createVoxelBox(2.5, 3.5, 0.2, 0x00FFFF, 0, 0, 0, true)); 
                    shGroup.add(createVoxelBox(2.8, 3.8, 0.1, 0x555555, 0, 0, 0)); 
                    shGroup.add(createVoxelBox(1.5, 0.2, 0.3, 0xFFFFFF, 0, 0, 0.2, true)); 
                    m.add(shGroup);
                    addGlow(m, 0x00FFFF);
                }
                else if(type==='rocket') {
                    m.add(createVoxelBox(1, 1, 3, CONFIG.colors.rocket, 0, 0, 0, true)); m.add(createVoxelBox(1.2, 1.2, 0.5, 0xFFFFFF, 0, 0, -1.5)); 
                    addGlow(m, 0xFF00FF);
                }
                else if(type==='wrench') {
                    m.add(createVoxelBox(0.8, 3.5, 0.5, 0xFF0000, 0, 0, 0)); 
                    m.add(createVoxelBox(2.0, 1.2, 0.5, 0xC0C0C0, 0, 1.5, 0, true)); 
                    addGlow(m, 0xCCCCCC);
                }
                else if(type==='balloon') {
                    m.add(createVoxelBox(4, 1, 4, CONFIG.colors.balloonMain, 0, 4, 0)); 
                    m.add(createVoxelBox(6, 4, 6, CONFIG.colors.balloonSec, 0, 1.5, 0));
                    m.add(createVoxelBox(2, 1, 2, CONFIG.colors.balloonMain, 0, -1, 0)); 
                    m.add(createVoxelBox(1.5, 1.5, 1.5, 0x553311, 0, -4, 0)); 
                    m.add(createVoxelBox(0.1, 3, 0.1, 0x000000, -0.6, -2.5, 0)); m.add(createVoxelBox(0.1, 3, 0.1, 0x000000, 0.6, -2.5, 0));
                    baseScale = 1.0;
                }
                else if(type==='drill') { 
                    m.add(createVoxelBox(1, 2, 1, 0x555555, 0, 0, 0)); m.add(createVoxelBox(1.2, 0.5, 1.2, 0xFFA500, 0, 0.5, 0));
                    m.add(createVoxelBox(0.8, 0.8, 0.8, 0xFFA500, 0, 1.2, 0)); m.add(createVoxelBox(0.4, 0.8, 0.4, 0xFFFFFF, 0, 1.8, 0, true)); 
                    addGlow(m, 0xFFA500);
                }
                
                if(!m.userData) m.userData = {};
                m.userData.type = type;
                if(!m.userData.baseScale) m.userData.baseScale = baseScale;
            }
            
            const spawnZ = plane.position.z - 400; 
            let spawnX = (Math.random()-0.5) * 60; 
            const h1 = getTerrainHeight(spawnX, spawnZ); const h2 = getTerrainHeight(spawnX - 2, spawnZ); const h3 = getTerrainHeight(spawnX + 2, spawnZ);
            const safeH = Math.max(h1, h2, h3);
            let spawnY = Math.max(safeH + 4, (Math.random() * 10) - 2);

            if(type === 'balloon' || (type === 'cloud' && Math.random() > 0.5)) { 
                spawnY = safeH + 22; spawnX = (Math.random()-0.5) * 32; 
            }

            m.position.set(spawnX, spawnY, spawnZ); 
            m.scale.set(baseScale, baseScale, baseScale);
            scene.add(m); objects.push(m);
        }

        function spawnParticles(pos, c, count=6) { 
            const mat = PARTICLE_MAT_BASE.clone();
            mat.color.setHex(c);
            for(let i=0;i<count;i++){
                let m = new THREE.Mesh(PARTICLE_GEO, mat);
                m.position.copy(pos); 
                m.userData = {vel:new THREE.Vector3((Math.random()-.5)*3,(Math.random()-.5)*3,(Math.random()-.5)*3)};
                scene.add(m); particles.push(m);
            } 
        }
        
        function checkCollision(plane, obj) {
            const dx = Math.abs(plane.position.x - obj.position.x); const dy = Math.abs(plane.position.y - obj.position.y); const dz = Math.abs(plane.position.z - obj.position.z);
            let hitX = 5, hitY = 2.5, hitZ = 3;
            if(['fuel', 'wrench', 'rocket', 'missile', 'drill', 'cloud'].includes(obj.userData.type)) { hitX = 8; hitY = 5; hitZ = 5; }
            if(obj.userData.type === 'balloon') { hitX = 4; hitY = 6; hitZ = 4; }
            
            // SPECIAL COLLISION FOR LASER
            if(obj.userData.type === 'alien_laser') {
                // Ignore Y check, laser is infinite verticality in practice
                // Laser width 15 -> hitX ~ 7.5 + plane slack -> 9
                // Z depth 15 -> hitZ ~ 7.5
                if(dx < 9 && dz < 7.5) return true;
                return false;
            }

            return (dx < hitX && dy < hitY && dz < hitZ);
        }

        function startGame() { 
            AudioSys.startGameMusic(); 
            isPlaying=true;
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('mobile-controls').classList.remove('hidden');
            clock.start();
            resetLogic(); 
        }

        function togglePause(){
            isPaused=!isPaused; 
            const pScreen = document.getElementById('pause-screen');
            pScreen.classList.toggle('hidden'); 
            
            if(isPaused) { 
                switchScreen('pause-screen');
                document.getElementById('mobile-controls').classList.add('hidden');
                if(AudioSys.engineGain) AudioSys.engineGain.gain.value = 0; 
                AudioSys.pauseMusic(true); 
                clock.stop();
            } 
            else { 
                pScreen.classList.add('hidden');
                document.getElementById('mobile-controls').classList.remove('hidden');
                AudioSys.pauseMusic(false); 
                clock.start();
            }
        }
        function quitToMenu() {
            isPaused = false; isPlaying = false; document.getElementById('pause-screen').classList.add('hidden');
            document.getElementById('mobile-controls').classList.add('hidden');
            AudioSys.startMenuMusic(); 
            resetGame(); if(AudioSys.engineGain) AudioSys.engineGain.gain.value = 0;
        }
        function resetGame(){ 
            document.getElementById('game-over-screen').classList.add('hidden'); 
            document.getElementById('mobile-controls').classList.add('hidden');
            switchScreen('start-screen');
            AudioSys.startMenuMusic(); 
        }
        
        function resetLogic(){
            score=0; distance=0; health=100; energy=50; 
            invincibleTimer=0; birdShieldTimer=0; drillTimer=0;
            
            comboCount = 0; comboTimer = 0; currentComboMultiplier = 1.0;
            document.getElementById('combo-wrapper').style.opacity = 0;
            
            // RESET OVERDRIVE
            document.getElementById('combo-container').classList.remove('combo-overdrive');
            document.getElementById('overdrive-overlay').style.opacity = 0;
            document.getElementById('overdrive-overlay').classList.remove('pulsing-gold');
            document.getElementById('combo-label-text').innerText = "COMBO !";

            isIntro = true; introStartTime = Date.now(); gameSpeed = 0; screenShake = 0; bounceForce = 0; wallHitTimer = 0; isInputLocked = false;
            mouseX=0; mouseY=0; joystickInput = {x:0, y:0}; isBoosting = false;

            objects.forEach(o=>scene.remove(o));objects=[]; particles.forEach(p=>scene.remove(p));particles=[];
            plane.position.set(0,0,0); plane.rotation.set(0,0,0); propeller.visible = true; drillMesh.visible = false; 
            terrainChunks.forEach(c=>scene.remove(c));terrainChunks=[]; for(let i=0;i<CONFIG.chunkCount;i++)terrainChunks.push(createChunk(-i*CONFIG.chunkSize));
            
            document.getElementById('shield-overlay').style.opacity = 0; document.getElementById('speed-overlay').style.opacity = 0;
            updateHUD();
        }

        function activateInvincibleBoost() { invincibleTimer = INVINCIBLE_DURATION; AudioSys.boost(); document.getElementById('speed-overlay').style.opacity = 1; }
        function activateBirdShield() { birdShieldTimer = BIRD_SHIELD_DURATION; AudioSys.boost(); document.getElementById('shield-overlay').style.opacity = 1; }
        function activateDrill() { drillTimer = DRILL_DURATION; AudioSys.drill(); propeller.visible = false; drillMesh.visible = true; }

        function triggerCombo() {
            comboCount++;
            comboTimer = COMBO_WINDOW;
            currentComboMultiplier = Math.min(10, 1 + (comboCount * 0.5));
            screenShake = 0.8; 
            
            const wrapper = document.getElementById('combo-wrapper');
            const container = document.getElementById('combo-container');
            wrapper.style.opacity = 1;
            
            if(comboCount >= 3) {
                container.classList.add('combo-overdrive');
                document.getElementById('combo-label-text').innerText = "OVERDRIVE !";
                const ov = document.getElementById('overdrive-overlay');
                ov.style.opacity = 1;
                ov.classList.add('pulsing-gold');
                energy = Math.min(100, energy + 95);
            }

            container.classList.remove('shake-anim');
            void container.offsetWidth; 
            container.classList.add('shake-anim');

            document.getElementById('combo-count-val').innerText = "x" + comboCount;
            document.getElementById('combo-mult-val').innerText = "BONUS x" + currentComboMultiplier.toFixed(1);
        }

        function takeDamage(amount) {
             if (invincibleTimer > 0 || isIntro || !isPlaying) return; 
             health -= amount; AudioSys.hit(); spawnParticles(plane.position, 0xFF0000); screenShake = 1.5; 
             const ov = document.getElementById('damage-overlay'); ov.style.opacity=1; setTimeout(()=>ov.style.opacity=0,200); 
             if(health<=0){ 
                 health = 0; isPlaying=false; AudioSys.gameOver(); 
                 document.getElementById('final-score').innerText=`${score} PTS`; document.getElementById('final-dist').innerText=`${Math.floor(distance)}M`; 
                 document.getElementById('mobile-controls').classList.add('hidden');
                 switchScreen('game-over-screen');
                 if(isHighScore(score)) { document.getElementById('highscore-form').classList.remove('hidden'); document.getElementById('player-name-input').value = ""; setTimeout(()=>document.getElementById('player-name-input').focus(), 100); } 
                 else { document.getElementById('highscore-form').classList.add('hidden'); }
            } updateHUD();
        }
        
        function healFull() { health = 100; AudioSys.heal(); const ov = document.getElementById('heal-overlay'); ov.style.opacity=1; setTimeout(()=>ov.style.opacity=0,300); updateHUD(); }
        function refillEnergy() { energy = Math.min(100, energy + 50); AudioSys.fuel(); updateHUD(); }

        function updateHUD() { 
            document.getElementById('score-display').innerText=score; document.getElementById('dist-display').innerText=Math.floor(distance) + " m";
            document.getElementById('health-fill').style.width = health + "%";
            document.getElementById('energy-fill').style.width = energy + "%";

            if(comboTimer > 0) {
                const pct = (comboTimer / COMBO_WINDOW);
                document.getElementById('combo-timer-fill').style.transform = `scaleX(${pct})`;
            }

            const elRocket = document.getElementById('effect-rocket');
            if(invincibleTimer > 0) {
                elRocket.classList.remove('hidden');
                document.getElementById('fill-rocket').style.transform = `scaleX(${invincibleTimer / INVINCIBLE_DURATION})`;
            } else { elRocket.classList.add('hidden'); document.getElementById('speed-overlay').style.opacity = 0; }

            const elShield = document.getElementById('effect-shield');
            if(birdShieldTimer > 0) {
                elShield.classList.remove('hidden');
                document.getElementById('fill-shield').style.transform = `scaleX(${birdShieldTimer / BIRD_SHIELD_DURATION})`;
            } else { elShield.classList.add('hidden'); document.getElementById('shield-overlay').style.opacity = 0; }

            const elDrill = document.getElementById('effect-drill');
            if(drillTimer > 0) {
                elDrill.classList.remove('hidden');
                document.getElementById('fill-drill').style.transform = `scaleX(${drillTimer / DRILL_DURATION})`;
            } else { elDrill.classList.add('hidden'); }
        }

        function animate() {
            requestAnimationFrame(animate); if(isPaused)return;
            
            if(!isPlaying){ plane.rotation.z=Math.sin(Date.now()*0.001)*0.05; propeller.rotation.z+=0.2; renderer.render(scene, camera); return; }

            const dt = Math.min(clock.getDelta(), 0.1); 
            const fpsFactor = dt * 60; 
            
            frameCount++; distance += gameSpeed * 0.1 * fpsFactor;
            if(wallHitTimer > 0) wallHitTimer -= fpsFactor;
            sunMesh.position.z = plane.position.z - 400; sunMesh.position.x = 0; sunMesh.position.y = 30;

            starField.position.x = plane.position.x; 
            starField.position.z = plane.position.z; 
            const positions = starField.geometry.attributes.position.array;
            for(let i=2; i<positions.length; i+=3) {
                 positions[i] += gameSpeed * 0.05 * fpsFactor; 
                 if(positions[i] > 200) positions[i] -= 800; 
            }
            starField.geometry.attributes.position.needsUpdate = true;

            const difficulty = getDifficultyMultiplier();
            const speedRatio = (gameSpeed - CONFIG.baseSpeed) / (CONFIG.maxBoostSpeed - CONFIG.baseSpeed);
            
            let engineVolMult = 1.0;
            if(isIntro) {
                 const elapsed = Date.now() - introStartTime;
                 engineVolMult = Math.min(1, elapsed / INTRO_DURATION_MS);
            }
            AudioSys.updateEngine(Math.max(0, speedRatio), engineVolMult);

            const sens = 0.02 * fpsFactor;
            mouseX += joystickInput.x * sens; 
            mouseY += joystickInput.y * sens;
            mouseX = Math.max(-1, Math.min(1, mouseX));
            mouseY = Math.max(-1, Math.min(1, mouseY));

            if(comboTimer > 0) {
                comboTimer -= fpsFactor;
                const pct = comboTimer / COMBO_WINDOW;
                document.getElementById('combo-timer-fill').style.transform = `scaleX(${pct})`;

                if(comboTimer <= 0) {
                    comboCount = 0; currentComboMultiplier = 1.0;
                    document.getElementById('combo-wrapper').style.opacity = 0;
                    
                    document.getElementById('combo-container').classList.remove('combo-overdrive');
                    document.getElementById('combo-label-text').innerText = "COMBO !";
                    document.getElementById('overdrive-overlay').style.opacity = 0;
                    document.getElementById('overdrive-overlay').classList.remove('pulsing-gold');
                }
            }

            if (birdShieldTimer > 0) birdShieldTimer -= fpsFactor;
            if (drillTimer > 0) { 
                drillTimer -= fpsFactor; drillMesh.rotation.y += 0.3 * fpsFactor; 
                if(drillTimer <= 0) { drillMesh.visible = false; propeller.visible = true; }
            }

            if (invincibleTimer > 0) {
                invincibleTimer -= fpsFactor; 
                gameSpeed = CONFIG.maxBoostSpeed; 
                if (invincibleTimer <= 0) gameSpeed = CONFIG.baseSpeed + (distance / 5000); 
            } else if (!isIntro) { 
                if (isBoosting && energy > 0) { gameSpeed = 3.5; energy -= 0.25 * fpsFactor; } else { gameSpeed = CONFIG.baseSpeed + (distance / 4000); }
            }
            updateHUD(); 

            if(gameSpeed > 3 && frameCount % Math.floor(3/fpsFactor) === 0) {
                const color = invincibleTimer > 0 ? 0xFF00FF : 0x00FFFF;
                spawnParticles(plane.position, color, 1);
            }
            
            let targetX, targetY;
            if (isIntro) {
                const elapsed = Date.now() - introStartTime; const progress = Math.min(1, elapsed / INTRO_DURATION_MS);
                gameSpeed = CONFIG.baseSpeed * progress;
                const terrainH = getTerrainHeight(0, plane.position.z);
                targetX = 0; targetY = (terrainH + 2) + ((0 - (terrainH + 2)) * progress);
                mouseX = 0; mouseY = 0; 
                if(elapsed >= INTRO_DURATION_MS) isIntro = false;
            }
            else if (isInputLocked) { targetX = 0; targetY = 0; } 
            else {
                targetX = mouseX * 45; 
                targetY = mouseY * 15;
            }
            
            bounceForce *= 0.9; 
            const smoothFactor = (isIntro ? 0.05 : 0.1) * fpsFactor; 
            plane.position.x += (targetX - plane.position.x) * smoothFactor + bounceForce; 
            plane.position.y += (targetY - plane.position.y) * smoothFactor;
            plane.position.z -= gameSpeed * fpsFactor;

            const terrainHeight = getTerrainHeight(plane.position.x, plane.position.z);
            if (!isIntro && plane.position.y < terrainHeight + 1.0) {
                if (invincibleTimer > 0) { plane.position.y = terrainHeight + 2; spawnParticles(plane.position, 0xffaa00, 3); } 
                else { takeDamage(20); plane.position.y = terrainHeight + 3; }
            }
            if (!isIntro && Math.abs(plane.position.x) > 32) {
                if(invincibleTimer <= 0 && wallHitTimer <= 0) {
                    takeDamage(25); wallHitTimer = 30; 
                    bounceForce = (plane.position.x > 0) ? -12.0 : 12.0;
                    // FIX: Reset input to prevent fighting the bounce
                    mouseX = 0; 
                    spawnParticles(plane.position, 0x8B4513, 10);
                } else if(invincibleTimer > 0) bounceForce = (plane.position.x > 0) ? -1.0 : 1.0;
            }

            plane.rotation.z = -(targetX - plane.position.x) * 0.05 - (bounceForce * 0.5); 
            if (isIntro) plane.rotation.x = -0.2; else plane.rotation.x = (targetY - plane.position.y) * 0.03; 
            propeller.rotation.z += (gameSpeed * 0.5 * fpsFactor);

            let baseFov = 60;
            if(comboCount >= 3) baseFov = 75; 
            if(gameSpeed > 2.5) baseFov += 10;
            
            camera.fov += (baseFov - camera.fov) * 0.05 * fpsFactor; 
            camera.updateProjectionMatrix();
            screenShake *= 0.9; if(screenShake < 0.01) screenShake = 0;
            
            camera.position.x += (plane.position.x * 0.9 - camera.position.x) * 0.1 * fpsFactor + (Math.random()-0.5) * screenShake; 
            camera.position.y = 10 + (plane.position.y * 0.3) + (Math.random()-0.5) * screenShake; 
            camera.position.z = plane.position.z + 28; 
            camera.lookAt(plane.position.x * 0.8, plane.position.y + 5, plane.position.z - 50);

            if(terrainChunks[0].position.z > plane.position.z + CONFIG.chunkSize) { scene.remove(terrainChunks[0]); terrainChunks.shift(); terrainChunks.push(createChunk(terrainChunks[terrainChunks.length-1].position.z - CONFIG.chunkSize)); }
            if(Math.floor(frameCount) % Math.floor(30/fpsFactor) === 0) spawnObject();

            for(let i=objects.length-1; i>=0; i--) {
                let o = objects[i]; 
                
                // POWER-UPS: SPIN + BIG PULSE
                if(['fuel', 'wrench', 'rocket', 'missile', 'drill'].includes(o.userData.type)) {
                    o.rotation.y += 0.05 * fpsFactor; 
                    let pulse = Math.sin(frameCount * 0.15) * 0.25; 
                    let s = o.userData.baseScale + pulse;
                    o.scale.set(s, s, s);
                }
                // BIRDS: WINGS + BOB
                else if(o.userData.type === 'bird') { 
                    if (o.userData.dead) { 
                        o.position.y -= 1.0 * fpsFactor; 
                        o.rotation.x += 0.2 * fpsFactor; 
                    } else { 
                        o.userData.wings[0].rotation.z = Math.sin(frameCount * 0.5); 
                        o.userData.wings[1].rotation.z = -Math.sin(frameCount * 0.5); 
                        o.position.z += 0.4 * fpsFactor;
                        o.position.y += Math.sin(frameCount * 0.1) * 0.02 * fpsFactor; 
                    } 
                }
                // BALLOON: HEAVY BREATHING + BOB
                else if(o.userData.type === 'balloon') {
                    o.position.y += Math.sin(frameCount * 0.05) * 0.1 * fpsFactor;
                    let pulse = Math.sin(frameCount * 0.05) * 0.15; 
                    let s = o.userData.baseScale + pulse;
                    o.scale.set(s, s, s);
                }
                // CLOUDS: SLOW BREATHING
                else if(o.userData.type === 'cloud') { 
                    o.lookAt(camera.position); 
                    // Add random id offset to de-sync breathing
                    let pulse = Math.sin((frameCount * 0.03) + o.userData.id) * 0.1;
                    let s = o.userData.baseScale + pulse;
                    o.scale.set(s, s, s);
                }
                // ALIEN LASER: PULSING + GROUND PARTICLES
                else if(o.userData.type === 'alien_laser') {
                    const beam = o.children.find(c => c.userData.isBeam);
                    if(beam) {
                        beam.material.opacity = 0.4 + Math.sin(frameCount * 0.5) * 0.2;
                    }
                    // Spawn particles at ground impact point
                    if(frameCount % 5 === 0) {
                        const groundH = getTerrainHeight(o.position.x, o.position.z);
                        const pPos = new THREE.Vector3(o.position.x + (Math.random()-0.5)*10, groundH + 1, o.position.z);
                        spawnParticles(pPos, 0xFF4400, 1);
                    }
                } 

                if(!o.userData.dead && checkCollision(plane, o)) { 
                    const timeMultiplier = 1 + (distance / 5000); 

                    if(o.userData.type==='bird'){ 
                        if (invincibleTimer > 0 || (isBoosting && energy > 0)) { 
                            score += Math.floor(500 * currentComboMultiplier * timeMultiplier); 
                            triggerCombo();
                            AudioSys.smash(); spawnParticles(o.position, 0xff3333, 10); o.userData.dead = true; 
                        } else if (birdShieldTimer > 0) { 
                            score += Math.floor(200 * currentComboMultiplier * timeMultiplier); 
                            triggerCombo();
                            AudioSys.hit(); o.userData.dead = true; 
                        } else { 
                            // CHANGED: Bird damage to 25
                            takeDamage(25); 
                        } 
                    }
                    else if(o.userData.type === 'balloon') { 
                        if (invincibleTimer > 0 || (isBoosting && energy > 0)) { 
                            score += Math.floor(1000 * currentComboMultiplier * timeMultiplier); 
                            triggerCombo();
                            AudioSys.smash(); spawnParticles(o.position, 0xFFFFFF, 20); scene.remove(o); objects.splice(i,1); 
                        } else if (drillTimer > 0) { 
                            score += Math.floor(1000 * currentComboMultiplier * timeMultiplier); 
                            triggerCombo();
                            AudioSys.smash(); spawnParticles(o.position, 0xFFFFFF, 20); scene.remove(o); objects.splice(i,1); 
                        } else { 
                            // CHANGED: Balloon damage verified at 50
                            takeDamage(50); 
                        } 
                    }
                    else if(o.userData.type === 'alien_laser') {
                        if (invincibleTimer > 0) {
                            // Can't destroy the laser, but don't take damage
                        } else {
                            takeDamage(50);
                            // Push back slightly to avoid multi-frame hits instantly killing
                            plane.position.z += 2; 
                        }
                    }
                    else if(o.userData.type==='rocket') { activateInvincibleBoost(); score+=500; spawnParticles(o.position, CONFIG.colors.rocket, 10); scene.remove(o); objects.splice(i,1); }
                    else if(o.userData.type==='drill') { activateDrill(); score+=500; spawnParticles(o.position, CONFIG.colors.drill, 10); scene.remove(o); objects.splice(i,1); }
                    else if(o.userData.type==='wrench') { healFull(); spawnParticles(o.position, CONFIG.colors.wrench, 10); scene.remove(o); objects.splice(i,1); }
                    else if(o.userData.type==='fuel') { refillEnergy(); spawnParticles(o.position, CONFIG.colors.fuel, 10); scene.remove(o); objects.splice(i,1); }
                    else if(o.userData.type==='missile') { activateBirdShield(); spawnParticles(o.position, CONFIG.colors.missile, 10); scene.remove(o); objects.splice(i,1); }
                    else { score+=100; AudioSys.coin(); spawnParticles(o.position, CONFIG.colors.cloud, 5); scene.remove(o); objects.splice(i,1); } 
                } 
                else if(o.position.z>plane.position.z+20 || o.position.y < -30){scene.remove(o);objects.splice(i,1);}
            }
            for(let i=particles.length-1; i>=0; i--){ particles[i].position.add(particles[i].userData.vel); particles[i].rotation.x += 0.1*fpsFactor; particles[i].scale.multiplyScalar(0.9); if(particles[i].scale.x<0.05){scene.remove(particles[i]);particles.splice(i,1);} }
            renderer.render(scene, camera);
        }
        init();
    </script>
</body>
</html>