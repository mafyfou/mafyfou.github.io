<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Plane Rush - HTML Madness</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: 'VT323', monospace; user-select: none; 
            -webkit-touch-callout: none; -webkit-user-select: none;
            touch-action: none; overscroll-behavior: none;
        }
        
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #110022; }
        ::-webkit-scrollbar-thumb { background: #FF00FF; border-radius: 4px; }

        #background-gradient {
            position: absolute; width: 100%; height: 100%; z-index: -2;
            background: linear-gradient(to bottom, #120024 0%, #4b0082 30%, #ff0055 60%, #ff8800 80%, #ffbd55 100%);
            transition: filter 2s;
        }
        
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; padding: 10px; box-sizing: border-box; 
            z-index: 10; display: flex; flex-direction: column; justify-content: space-between; 
        }

        #floating-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 9; overflow: hidden;
        }

        .floating-text {
            position: absolute;
            font-family: 'VT323', monospace;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            will-change: transform, opacity;
            animation: floatUp 0.8s ease-out forwards;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            50% { transform: translateY(-30px) scale(1.2); opacity: 1; }
            100% { transform: translateY(-60px) scale(1); opacity: 0; }
        }

        #overdrive-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 5;
            box-shadow: inset 0 0 100px rgba(255, 215, 0, 0.6), inset 0 0 20px rgba(255, 215, 0, 0.8);
            opacity: 0; transition: opacity 0.5s, box-shadow 0.5s;
            mix-blend-mode: screen;
        }
        .pulsing { animation: pulseOverdrive 0.5s infinite alternate; }
        @keyframes pulseOverdrive { from { opacity: 0.4; } to { opacity: 0.8; } }

        .hud-top { 
            display: flex; flex-direction: column; width: 100%; align-items: center; gap: 5px; 
            margin-top: env(safe-area-inset-top); 
            position: relative; 
        }

        .status-bars { 
            display: flex; flex-direction: row; gap: 8px; width: 100%; 
            justify-content: space-between; align-items: center; margin-bottom: 5px; 
            pointer-events: auto; 
        }

        .stats-row {
            display: flex; flex-direction: row; width: 100%; justify-content: space-between; align-items: center;
            pointer-events: auto;
        }

        #combo-wrapper { 
            position: absolute; bottom: 180px; right: 20px; 
            opacity: 0; transition: opacity 0.2s; pointer-events: none; 
            transform-origin: right center; scale: 0.8; top: auto; left: auto;
        }

        @media (min-aspect-ratio: 1/1) {
            .hud-top { padding: 10px 40px; align-items: center; }
            .status-bars { width: 100%; max-width: 1200px; margin-bottom: 10px; }
            .stats-row { width: auto; justify-content: center; gap: 40px; }
            .hud-box.score-box { order: 1; }
            #pause-btn { order: 2; margin: 0; }
            .hud-box.dist-box { order: 3; }
            #combo-wrapper { bottom: auto; right: auto; top: 45%; left: 60%; transform: translateX(0); scale: 1.0; }
        }

        .bar-wrapper { position: relative; flex: 1; height: 24px; background: #111; border: 2px solid #FFF; display: flex; align-items: center; padding: 1px; }
        .bar-icon-box { width: 24px; height: 100%; background: #222; display: flex; align-items: center; justify-content: center; border-right: 2px solid #FFF; margin-right: 2px; color: #FFF; font-size: 16px; z-index: 2; }
        .bar-fill-container { flex-grow: 1; height: 100%; position: relative; background: #2a0e2a; }
        .bar-fill { height: 100%; width: 100%; transition: width 0.1s linear; position: relative; }
        .bar-fill::after { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.2) 4px); }

        #health-wrapper { border-color: #FF0055; margin-right: 2px;}
        #health-wrapper .bar-icon-box { background: #FF0055; color: #111; border-right-color: #FF0055; }
        #health-fill { background: linear-gradient(90deg, #880000, #FF0055); box-shadow: 0 0 5px #FF0055; }
        #energy-wrapper { border-color: #00FFFF; margin-left: 2px;}
        #energy-wrapper .bar-icon-box { background: #00FFFF; color: #111; border-right-color: #00FFFF; }
        #energy-fill { background: linear-gradient(90deg, #004488, #00FFFF); box-shadow: 0 0 5px #00FFFF; }

        #pause-btn {
            width: 50px; height: 40px; background: rgba(0, 0, 0, 0.8); border: 2px solid #FFF;
            color: #FFF; font-size: 24px; display: flex; align-items: center; justify-content: center;
            border-radius: 4px; cursor: pointer; flex-shrink: 0; box-shadow: 0 0 5px rgba(255,255,255,0.5);
            font-weight: bold; letter-spacing: 2px;
        }
        #pause-btn:active, .btn.selected { background: #FFF; color: #000; }

        .hud-box { 
            background: rgba(20, 0, 40, 0.85); padding: 2px 8px; border: 2px solid #00FFFF; border-radius: 4px;
            box-shadow: 0 0 5px #00FFFF; color: #FFF; font-size: 24px; 
            display: flex; flex-direction: column; align-items: center; min-width: 80px; text-shadow: 1px 1px 0 #b82e8a;
        }
        .hud-label { font-size: 14px; color: #FF00FF; text-transform: uppercase; letter-spacing: 1px; }

        #combo-container { display: flex; flex-direction: column; align-items: flex-end; transition: all 0.3s; }
        .combo-count { font-size: 60px; color: #FFFF00; text-shadow: 3px 3px 0 #FF0000; line-height: 0.8; font-style: italic; font-weight: bold; transition: color 0.3s, text-shadow 0.3s; }
        .combo-label { font-size: 24px; color: #FFA500; letter-spacing: 2px; text-shadow: 1px 1px 0 #000; transition: color 0.3s; }
        .combo-mult { font-size: 30px; color: #00FFFF; text-shadow: 1px 1px 0 #0000FF; margin-top: 2px; transition: color 0.3s; }
        .combo-bar-bg { width: 150px; height: 8px; background: rgba(0,0,0,0.5); border: 1px solid #FFF; margin-top: 2px; skew-x: -20deg; transition: border-color 0.3s; }
        #combo-timer-fill { height: 100%; width: 100%; background: linear-gradient(90deg, #FF8800, #FFFF00); transform-origin: left; transition: transform 0.1s linear, background 0.3s; }
        .shake-anim { animation: shake 0.2s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake { 10%, 90% { transform: translate3d(-2px, -2px, 0); } 20%, 80% { transform: translate3d(4px, 4px, 0); } 30%, 50%, 70% { transform: translate3d(-6px, -2px, 0); } 40%, 60% { transform: translate3d(6px, 2px, 0); } }

        #mobile-controls {
            position: absolute; bottom: 10px; left: 0; width: 100%; height: 160px; pointer-events: auto; z-index: 50;
            display: flex; justify-content: space-between; align-items: flex-end; padding: 0 20px;
            padding-bottom: env(safe-area-inset-bottom); box-sizing: border-box; touch-action: none; 
        }
        #joystick-zone { width: 140px; height: 140px; display: flex; align-items: center; justify-content: center; position: relative; }
        #joystick-base { width: 120px; height: 120px; border-radius: 50%; background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.3); box-shadow: 0 0 10px rgba(0, 0, 0, 0.5); position: relative; }
        #joystick-stick { width: 50px; height: 50px; border-radius: 50%; background: radial-gradient(#00FFFF, #008888); border: 2px solid #FFF; box-shadow: 0 0 10px #00FFFF; position: absolute; top: 50%; left: 50%; margin-top: -25px; margin-left: -25px; pointer-events: none; }
        #boost-zone { width: 120px; height: 140px; display: flex; align-items: center; justify-content: center; margin-right: 15px; }
        #boost-btn { width: 90px; height: 90px; border-radius: 50%; background: radial-gradient(circle at 30% 30%, #ff8800, #ff0000); border: 4px solid #FFFFFF; color: #FFF; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 18px; font-weight: bold; text-shadow: 1px 1px 0 #000; box-shadow: 0 4px 10px rgba(0,0,0,0.5), 0 0 15px #FF4500; transition: transform 0.1s; }
        #boost-btn:active { transform: scale(0.9); background: radial-gradient(circle at 30% 30%, #ffffff, #ff8800); color: #000; text-shadow: none; box-shadow: 0 0 25px #ffaa00; }
        #boost-btn span { font-size: 30px; line-height: 20px; display: block; margin-bottom: 2px; }

        #active-effects-container { position: absolute; top: 150px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; gap: 5px; width: 300px; pointer-events: none; }
        .effect-row { display: flex; flex-direction: column; background: rgba(0,0,0,0.7); border: 2px solid; padding: 3px; opacity: 1; transition: opacity 0.3s; }
        .effect-row.hidden { opacity: 0; }
        .effect-label { font-size: 18px; text-shadow: 1px 1px 0 #000; margin-bottom: 2px; text-align: center; letter-spacing: 1px;}
        .effect-bar-bg { width: 100%; height: 6px; background: rgba(255,255,255,0.1); }
        .effect-bar-fill { height: 100%; width: 100%; transform-origin: left; transition: transform 0.1s linear; }
        
        .style-rocket { border-color: #FF00FF; color: #FF00FF; }
        .style-rocket .effect-bar-fill { background: repeating-linear-gradient(45deg, #FF00FF, #FF00FF 10px, #FFFFFF 10px, #FFFFFF 20px); }
        .style-shield { border-color: #00FFFF; color: #00FFFF; }
        .style-shield .effect-bar-fill { background: #00FFFF; }
        .style-drill { border-color: #FFFF00; color: #FFFF00; }
        .style-drill .effect-bar-fill { background: #FFFF00; }

        .overlay-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(20, 0, 30, 0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; transition: opacity 0.3s; }
        .btn { 
            background: #FF00FF; color: #FFF; border: 4px solid #FFF; padding: 15px 40px; 
            font-size: 30px; font-family: 'VT323', monospace; cursor: pointer; 
            box-shadow: 0 0 15px #FF00FF; transition: transform 0.1s; margin: 10px;
            text-shadow: 2px 2px 0 #000; outline: none; -webkit-tap-highlight-color: transparent;
        }
        .btn:active, .btn.selected { transform: scale(0.95); background: #FFF; color: #FF00FF; }
        .btn-small { padding: 8px 15px; font-size: 20px; background: #00FFFF; box-shadow: 0 0 15px #00FFFF; color: #000; border-color: #000; width: 130px;}
        .menu-row { display: flex; gap: 10px; justify-content: center; width: 100%; max-width: 400px; flex-wrap: wrap; }

        .leaderboard-container { background: rgba(0,0,0,0.4); padding: 15px; border: 4px solid #00FFFF; margin-bottom: 20px; width: 300px; color: white; text-align: center; font-size: 20px; box-shadow: 0 0 10px #00FFFF;}
        .score-entry { display: flex; justify-content: space-between; border-bottom: 1px dashed #FF00FF; margin: 5px 0; color: #00FFFF; }
        #highscore-form { display: flex; flex-direction: column; align-items: center; gap: 10px; margin-bottom: 20px; background: rgba(0, 50, 0, 0.6); padding: 15px; border: 2px solid #00FF00; }
        #player-name-input { background: #000; color: #00FF00; border: 2px solid #00FF00; font-family: 'VT323', monospace; font-size: 30px; text-align: center; width: 200px; padding: 5px; text-transform: uppercase; }
        
        .audio-settings-box { background: rgba(0,0,0,0.9); border: 4px solid #FF00FF; padding: 20px; width: 90%; max-width: 400px; color: white; text-align: center; box-shadow: 0 0 20px #FF00FF; }
        .slider-group { margin: 15px 0; text-align: left; }
        .slider-label { display: flex; justify-content: space-between; color: #00FFFF; font-size: 20px; margin-bottom: 5px; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #FF00FF; height: 20px; }

        .guide-box { 
            background: rgba(10, 0, 20, 0.95); border: 4px solid #00FFFF; 
            padding: 10px; width: 90%; max-width: 500px; height: 70%;
            color: white; display: flex; flex-direction: column;
            box-shadow: 0 0 20px #00FFFF, inset 0 0 30px rgba(0,255,255,0.2);
            position: relative;
        }
        .guide-content { flex: 1; overflow-y: auto; padding-right: 10px; text-align: left; }
        .guide-section { margin-bottom: 20px; border-bottom: 2px solid #FF00FF; padding-bottom: 10px; }
        .guide-title { color: #FF00FF; font-size: 28px; margin-bottom: 10px; text-shadow: 2px 2px 0 #000; letter-spacing: 2px;}
        .guide-item { display: flex; align-items: center; margin-bottom: 10px; background: rgba(255,255,255,0.05); padding: 5px; border-radius: 4px; }
        .guide-icon { width: 40px; height: 40px; margin-right: 15px; border: 2px solid white; flex-shrink: 0; display: flex; align-items: center; justify-content: center; font-size: 20px; text-shadow: 1px 1px 0 #000; box-shadow: 0 0 5px currentColor; }
        .guide-desc { flex: 1; font-size: 18px; color: #DDD; line-height: 1.1; }
        .guide-desc strong { color: #00FFFF; display: block; font-size: 20px; margin-bottom: 2px; }
        
        .icon-fuel { background: #FF0000; color: #FF0000; box-shadow: 0 0 8px #FF0000;}
        .icon-wrench { background: #C0C0C0; color: #C0C0C0; box-shadow: 0 0 8px #C0C0C0;}
        .icon-score { background: #FFFFFF; color: #FFFFFF; box-shadow: 0 0 8px #FFFFFF;}
        .icon-rocket { background: repeating-linear-gradient(45deg, #FF00FF, #FF00FF 5px, #FFF 5px, #FFF 10px); color: #FF00FF; border-color: #FF00FF;}
        .icon-shield { background: #00FFFF; color: #00FFFF; box-shadow: 0 0 10px #00FFFF; }
        .icon-drill { background: #FFFF00; color: #FFFF00; box-shadow: 0 0 10px #FFFF00; }
        .icon-bird { background: #4A4A4A; border-color: #B87333; }
        .icon-balloon { background: #8B4513; border-color: #F5DEB3; }
        .icon-ufo { background: #333333; border-color: #00FF00; color: #FF0000; }
        .icon-bridge { background: #8B4513; border-color: #D2691E; }

        #damage-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 40%, rgba(255,0,0,0.6) 100%); opacity: 0; pointer-events: none; transition: opacity 0.1s; z-index: 50; }
        #heal-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 40%, rgba(0,255,0,0.4) 100%); opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 50; }
        #speed-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 50%, rgba(255, 0, 255, 0.2) 80%, rgba(255, 255, 255, 0.4) 100%); opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 40; mix-blend-mode: hard-light; }
        #shield-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 50%, rgba(0, 255, 0, 0.2) 100%); opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 40; mix-blend-mode: screen; }

        .hidden { display: none !important; }
        h1 { font-size: 70px; color: #FF00FF; text-shadow: 4px 4px 0 #00FFFF; margin: 0; line-height: 0.9; text-align: center; font-style: italic; }
        h1 span { display: block; font-size: 35px; color: #FFFF00; text-shadow: 2px 2px 0 #FF0000; transform: rotate(-2deg); margin-top: 5px; font-style: normal;}
    .quest-item { margin-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 2px; }
.quest-completed { color: #00ff66 !important; text-decoration: line-through; font-weight: bold; }
.quest-completed::after { content: " âœ“"; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
</head>
<body>
    <div id="background-gradient"></div>
    <div id="overdrive-overlay"></div>
    <div id="floating-layer"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="status-bars">
                <div class="bar-wrapper" id="health-wrapper">
                    <div class="bar-icon-box">âœš</div>
                    <div class="bar-fill-container"><div class="bar-fill" id="health-fill"></div></div>
                </div>
                
                <div class="bar-wrapper" id="energy-wrapper">
                    <div class="bar-icon-box">âš¡</div>
                    <div class="bar-fill-container"><div class="bar-fill" id="energy-fill"></div></div>
                </div>
            </div>
            
            <div class="stats-row">
                <div class="hud-box score-box"><span class="hud-label">Score</span><span id="score-display">0</span></div>
                <div id="pause-btn" onclick="togglePause()">||</div>
                <div class="hud-box dist-box"><span class="hud-label">Distance</span><span id="dist-display">0 m</span></div>
            </div>
        </div>
        
        <div id="combo-wrapper">
            <div id="combo-container">
                <div class="combo-label" id="combo-label-text">COMBO !</div>
                <div class="combo-count" id="combo-count-val">x0</div>
                <div class="combo-mult" id="combo-mult-val">BONUS x1.0</div>
                <div class="combo-bar-bg"><div id="combo-timer-fill"></div></div>
            </div>
        </div>

        <div id="active-effects-container">
            <div id="effect-rocket" class="effect-row style-rocket hidden">
                <div class="effect-label">HYPER VITESSE</div>
                <div class="effect-bar-bg"><div class="effect-bar-fill" id="fill-rocket"></div></div>
            </div>
            <div id="effect-shield" class="effect-row style-shield hidden">
                <div class="effect-label">BOUCLIER ANTI-OISEAUX</div>
                <div class="effect-bar-bg"><div class="effect-bar-fill" id="fill-shield"></div></div>
            </div>
            <div id="effect-drill" class="effect-row style-drill hidden">
                <div class="effect-label">VRILLE FORAGE</div>
                <div class="effect-bar-bg"><div class="effect-bar-fill" id="fill-drill"></div></div>
            </div>
        </div>

        <div id="mobile-controls" class="hidden">
            <div id="joystick-zone">
                <div id="joystick-base">
                    <div id="joystick-stick"></div>
                </div>
            </div>
            <div id="boost-zone">
                <div id="boost-btn"><span>â–²</span>BOOST</div>
            </div>
        </div>

    </div>
    <div id="damage-overlay"></div><div id="heal-overlay"></div><div id="speed-overlay"></div><div id="shield-overlay"></div>

    <div id="start-screen" class="overlay-screen">
        <h1>PLANE RUSH<span>HTML Madness</span></h1>
        <div id="turbo-container" style="display:none; margin-bottom: 10px;">
    <label style="color: #ff0055; font-weight: bold; font-size: 24px; cursor: pointer; text-shadow: 2px 2px 0 #fff; background: rgba(0,0,0,0.5); padding: 5px 10px; border: 2px solid #ff0055;">
        <input type="checkbox" id="turbo-toggle"> ðŸš€ MODE TURBO (VITESSE x2)
    </label>
</div>

<div id="daily-quests" style="width: 300px; background: rgba(0, 0, 0, 0.6); padding: 10px; border: 2px solid #444; margin-bottom: 15px; text-align: left;">
    <h3 style="margin: 0 0 5px 0; color: #ffcc00; text-align: center; font-size: 20px;">QUÃŠTES DU JOUR</h3>
    <ul id="quest-list-main" style="list-style: none; padding: 0; margin: 0; color: white; font-size: 16px;"></ul>
</div>
        <div class="leaderboard-container"><div style="color:#FFFF00; margin-bottom:10px;">MEILLEURS PILOTES</div><div id="lb-start"></div></div>
        
        <div class="menu-row">
            <button class="btn btn-small" style="width:auto; background:#FFD700; color:#000;" onclick="AudioSys.unlock(); openSkinMenu()">GARAGE</button>
        </div>

        <div class="menu-row" style="margin-top:10px;">
            <button class="btn btn-small" onclick="AudioSys.unlock(); openGuide()">GUIDE</button>
            <button class="btn btn-small" onclick="AudioSys.unlock(); openAudioSettings()">PARAMETRES</button>
        </div>

        <p style="color:#00FFFF; font-size: 20px; text-shadow: 2px 2px 0 #FF00FF; margin: 15px 0;">CHOISISSEZ VOS COMMANDES</p>
        <div class="menu-row">
            <button class="btn" onclick="startGame('touch')">TACTILE</button>
            <button class="btn" onclick="startGame('mouse')">SOURIS</button>
            <button class="btn" onclick="startGame('keyboard')">CLAVIER</button>
        </div>
    </div>

    <div id="skin-screen" class="overlay-screen hidden">
        <h2 style="color:#00FFFF; font-size:50px; margin-bottom:10px;">GARAGE</h2>
        
        <div id="garage-3d-container" style="width: 300px; height: 250px; background: radial-gradient(circle, #2a0e2a, #000); border: 4px solid #FF00FF; margin-bottom: 10px; position: relative; cursor: move; touch-action: none;"></div>
        <div style="font-size: 14px; color: #AAA; margin-top: -5px; margin-bottom: 10px;">(FAITES TOURNER L'AVION)</div>

        <div style="text-align:center; margin-bottom:10px;">
            <div id="skin-name" style="font-size:30px; color:#FFF; text-shadow: 2px 2px 0 #FF00FF;">NOM DU SKIN</div>
            <div id="skin-model-label" style="font-size:18px; color:#AAA;">MODÃˆLE A</div>
        </div>

        <div class="menu-row" style="align-items: center; gap: 10px; flex-wrap: nowrap; width: 100%; max-width: 500px;">
    <button class="btn" style="padding: 10px 15px; margin: 0;" onclick="changeSkin(-1)">â—€</button>
    
    <button class="btn" id="select-skin-btn" style="background:#00FF00; color:#000; border-color:#005500; width: 160px; margin: 0; font-size: 24px;" onclick="selectSkin()">CHOISIR</button>
    
    <button class="btn" style="padding: 10px 15px; margin: 0;" onclick="changeSkin(1)">â–¶</button>
</div>

        <button class="btn btn-small" style="margin-top:20px;" onclick="closeSkinMenu()">RETOUR</button>
    </div>

    <div id="guide-screen" class="overlay-screen hidden">
        <div class="guide-box">
            <h2 style="color:#00FFFF; text-align:center; margin: 0 0 15px 0; border-bottom: 2px solid white; padding-bottom: 5px;">MANUEL DE VOL</h2>
            <div class="guide-content">
                <div class="guide-section">
                    <div class="guide-title">COMMANDES</div>
                    <div class="guide-item"><div class="guide-desc"><strong>TACTILE</strong>Joystick virtuel + Bouton Boost.</div></div>
                    <div class="guide-item"><div class="guide-desc"><strong>SOURIS</strong>La souris dirige l'avion (Pointer Lock). Clic = Boost.</div></div>
                    <div class="guide-item"><div class="guide-desc"><strong>CLAVIER</strong>FlÃ¨ches directionnelles. Espace = Boost. Tab/Echap = Pause.</div></div>
                </div>
                <div class="guide-section">
                    <div class="guide-title">RAVITAILLEMENT</div>
                    <div class="guide-item"><div class="guide-icon icon-fuel"></div><div class="guide-desc"><strong>CARBURANT (Rouge)</strong>Recharge 50% d'Ã©nergie.</div></div>
                    <div class="guide-item"><div class="guide-icon icon-wrench"></div><div class="guide-desc"><strong>RÃ‰PARATION (Gris)</strong>RÃ©pare 100% de la structure.</div></div>
                    <div class="guide-item"><div class="guide-icon icon-score"></div><div class="guide-desc"><strong>BONUS & OVERDRIVE</strong>Combo 3+ = +95% de Boost par kill !</div></div>
                </div>
                <div class="guide-section">
                    <div class="guide-title">POWER-UPS</div>
                    <div class="guide-item"><div class="guide-icon icon-rocket"></div><div class="guide-desc"><strong>GIGA FUSÃ‰E (Rose)</strong>Hyper Vitesse et invincibilitÃ©.</div></div>
                    <div class="guide-item"><div class="guide-icon icon-shield"></div><div class="guide-desc"><strong>BOUCLIER ANTI-OISEAUX (Cyan)</strong>ProtÃ¨ge des oiseaux.</div></div>
                    <div class="guide-item"><div class="guide-icon icon-drill"></div><div class="guide-desc"><strong>VRILLE Ã€ BALLONS(Jaune)</strong>DÃ©truit les ballons sur votre chemin.</div></div>
                </div>
                <div class="guide-section">
                    <div class="guide-title">DANGERS</div>
                    <div class="guide-item"><div class="guide-icon icon-bird"></div><div class="guide-desc"><strong>OISEAUX MÃ‰CANIQUES</strong>DÃ©gÃ¢ts lÃ©gers (25). Certains se dÃ©placent (1/10).</div></div>
                    <div class="guide-item"><div class="guide-icon icon-balloon"></div><div class="guide-desc"><strong>BALLONS MINES</strong>DÃ©gÃ¢ts lourds (50). ContrÃ© par la Vrille.</div></div>
                    <div class="guide-item"><div class="guide-icon icon-ufo">UFO</div><div class="guide-desc"><strong>LASER ALIEN</strong>Rayon vertical rouge (DÃ©gÃ¢ts 50). Esquivez !</div></div>
                    <div class="guide-item"><div class="guide-icon icon-bridge">=</div><div class="guide-desc"><strong>PONT DE CORDE</strong>Passez EN DESSOUS ou AU DESSUS (DÃ©gÃ¢ts 50).</div></div>
                </div>
            </div>
            <button class="btn" style="margin: 10px auto 0 auto; font-size: 24px; padding: 5px 30px;" onclick="closeGuide()">RETOUR</button>
        </div>
    </div>

    <div id="audio-screen" class="overlay-screen hidden">
        <div class="audio-settings-box">
            <h2 style="color:#00FFFF; margin-bottom: 20px;">PARAMETRES</h2>
            <div class="slider-group"><div class="slider-label"><span>QUALITÃ‰</span> <span id="res-val">AUTO</span></div><input type="range" min="50" max="300" value="0" id="res-slider" oninput="updateResolution(this.value)"></div>
            <div class="slider-group"><div class="slider-label"><span>SENSIBILITÃ‰</span> <span id="sens-val">1.0</span></div><input type="range" min="0" max="2" step="0.05" value="1" oninput="updateSensitivity(this.value)"></div>
            <div class="slider-group"><div class="slider-label"><span>MUSIQUE</span> <span id="vol-music-val">40%</span></div><input type="range" min="0" max="100" value="40" oninput="updateAudioSettings('music', this.value)"></div>
            <div class="slider-group"><div class="slider-label"><span>MOTEUR</span> <span id="vol-engine-val">30%</span></div><input type="range" min="0" max="100" value="30" oninput="updateAudioSettings('engine', this.value)"></div>
            <div class="slider-group"><div class="slider-label"><span>EFFETS</span> <span id="vol-sfx-val">50%</span></div><input type="range" min="0" max="100" value="50" oninput="updateAudioSettings('sfx', this.value)"></div>
            <button class="btn" onclick="closeAudioSettings()">RETOUR</button>
        </div>
    </div>
    
    <div id="pause-screen" class="overlay-screen hidden">
        <h1>PAUSE</h1>
        <div style="width: 300px; background: rgba(0, 0, 0, 0.6); padding: 10px; border: 1px solid #444; margin-bottom: 15px; text-align: left;">
    <h3 style="margin: 0 0 5px 0; color: #ffcc00; text-align: center; font-size: 18px;">PROGRESSION</h3>
    <ul id="quest-list-pause" style="list-style: none; padding: 0; margin: 0; color: white; font-size: 16px;"></ul>
</div>
        <button class="btn" onclick="togglePause()">REPRENDRE</button>
        <button class="btn btn-small" onclick="quitToMenu()" style="margin-top:20px; background:#cc3333; color:#fff; border-color:#fff;">QUITTER</button>
        <div style="color:#CCC; margin-top:10px; font-size:18px;">(TAB / ECHAP pour Reprendre)</div>
    </div>
    
    <div id="game-over-screen" class="overlay-screen hidden">
        <h1 style="color:#ff3333; text-shadow: 4px 4px 0 #3e2723;">CRASH!</h1>
        <div class="hud-box" style="align-items: center; margin: 10px 0;">
            <span class="hud-label">Rapport Final</span>
            <span id="final-score">Score: 0</span>
            <span id="final-dist" style="font-size:25px; color:#aaa">Dist: 0m</span>
        </div>
        <div id="highscore-form" class="hidden">
            <div style="color:#00FF00; font-size:24px; text-align:center;">NOUVEAU RECORD !<br>Nom :</div>
            <input type="text" id="player-name-input" maxlength="8" placeholder="PILOTE">
            <button class="btn btn-small" onclick="submitHighScore()" style="background:#00FF00; color:#000; border-color:#005500;">VALIDER</button>
        </div>
        <div class="leaderboard-container"><div style="color:#FFD700; margin-bottom:10px;">TOP 5</div><div id="lb-end"></div></div>
        <button class="btn" onclick="resetGame()">RÃ‰ESSAYER</button>
    </div>

    <script>
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const VOLUMES = { music: 0.4, engine: 0.3, sfx: 0.5 };
        let renderScale = 0; 
        const clock = new THREE.Clock(); 

        const PARTICLE_GEO = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        const PARTICLE_MAT_BASE = new THREE.MeshBasicMaterial();

const QUEST_DB = [
    { id: 1, text: "Distance: 5000m (Total)", type: 'dist', target: 5000, single: false },
    { id: 2, text: "Distance: 2000m (1 Vie)", type: 'dist', target: 2000, single: true },
    { id: 3, text: "Score: 2000 pts (1 Vie)", type: 'score', target: 2000, single: true },
    { id: 4, text: "Score: 10000 pts (Total)", type: 'score', target: 10000, single: false },
    { id: 5, text: "Faire un Combo x20", type: 'combo', target: 20, single: true },
    { id: 6, text: "Ã‰liminer 50 Ennemis (Total)", type: 'kill', target: 50, single: false },
    { id: 7, text: "Ramasser 10 Bonus (Total)", type: 'collect', target: 10, single: false },
    { id: 8, text: "Survivre 3000m (1 Vie)", type: 'dist', target: 3000, single: true }
];

let dailyQuests = [];
let enemiesKilled = 0; 
let itemsCollected = 0; 
let isTurboMode = false;

function initDailyQuests() {
    const today = new Date().toDateString();
    const savedDate = localStorage.getItem('pr_questDate');
    const savedQuests = localStorage.getItem('pr_dailyQuests');

    if (savedDate === today && savedQuests) {
        dailyQuests = JSON.parse(savedQuests);
    } else {
        dailyQuests = [];
        let pool = [...QUEST_DB];
        for (let i = 0; i < 3; i++) {
            if (pool.length === 0) break;
            const ridx = Math.floor(Math.random() * pool.length);
            dailyQuests.push({ ...pool.splice(ridx, 1)[0], progress: 0, completed: false });
        }
        saveQuests();
        localStorage.setItem('pr_questDate', today);
    }
    checkTurboUnlock();
    renderQuests();
}

function saveQuests() { localStorage.setItem('pr_dailyQuests', JSON.stringify(dailyQuests)); }

function checkTurboUnlock() {
    const allDone = dailyQuests.every(q => q.completed);
    const turboDiv = document.getElementById('turbo-container');
    if(turboDiv) turboDiv.style.display = allDone ? "block" : "none";
}

function renderQuests() {
    ['quest-list-main', 'quest-list-pause'].forEach(id => {
        const ul = document.getElementById(id);
        if(!ul) return;
        ul.innerHTML = '';
        dailyQuests.forEach(q => {
            const li = document.createElement('li');
            li.className = 'quest-item';
            let prog = q.completed ? q.target : q.progress;
            if(q.single && !q.completed) prog = 0; 
            let txt = q.type === 'combo' ? q.text : `${q.text} (${Math.floor(prog)}/${q.target})`;
            if(q.completed) txt = q.text;
            
            li.innerText = txt;
            if(q.completed) li.classList.add('quest-completed');
            ul.appendChild(li);
        });
    });
}

function updateLiveQuests(stats) {
    let changed = false;
    dailyQuests.forEach(q => {
        if (q.completed) return;
        let val = 0;
        if (q.type === 'dist') val = stats.dist;
        if (q.type === 'score') val = stats.score;
        if (q.type === 'combo') val = stats.combo;
        
        if (q.single && val >= q.target) {
            q.progress = q.target; q.completed = true; changed = true;
            spawnFloatingText("QUÃŠTE OK!", plane.position, "#00FF66");
            AudioSys.coin();
        }
    });
    if (changed) { saveQuests(); renderQuests(); checkTurboUnlock(); }
}

function finalizeQuests(runStats) {
    dailyQuests.forEach(q => {
        if (q.completed || q.single) return;
        if (q.type === 'dist') q.progress += runStats.dist;
        if (q.type === 'score') q.progress += runStats.score;
        if (q.type === 'kill') q.progress += runStats.kill;
        if (q.type === 'collect') q.progress += runStats.collect;
        
        if (q.progress >= q.target) { q.progress = q.target; q.completed = true; }
    });
    saveQuests(); renderQuests(); checkTurboUnlock();
}

        const AudioSys = { 
            ctx: null, engineOsc: null, engineGain: null, bgMusic: null, menuMusic: null,
            init: function() { 
                if(!this.ctx) { 
                    this.ctx = new (window.AudioContext||window.webkitAudioContext)(); 
                    this.engineOsc = this.ctx.createOscillator(); this.engineGain = this.ctx.createGain(); 
                    this.engineOsc.type = 'sawtooth'; this.engineOsc.frequency.value = 60; this.engineGain.gain.value = 0; 
                    this.engineOsc.connect(this.engineGain); this.engineGain.connect(this.ctx.destination); this.engineOsc.start(); 
                    this.bgMusic = new Audio('music.mp3'); this.bgMusic.loop = true; this.bgMusic.volume = VOLUMES.music;
                    this.menuMusic = new Audio('main_menu_music.mp3'); this.menuMusic.loop = true; this.menuMusic.volume = VOLUMES.music;
                } 
            },
            unlock: function() {
                if(!this.ctx) this.init();
                if(this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
                if(this.menuMusic && this.menuMusic.paused && (!this.bgMusic || this.bgMusic.paused)) {
                    this.menuMusic.play().catch(e=>{});
                }
            },
            updateEngine: function(ratio, volMult = 1.0) { 
                if(!this.engineOsc) return; 
                this.engineOsc.frequency.setTargetAtTime(60 + (ratio * 100), this.ctx.currentTime, 0.1); 
                const dynamicVol = 0.05 + (ratio * 0.05);
                this.engineGain.gain.setTargetAtTime(dynamicVol * (VOLUMES.engine * 2) * volMult, this.ctx.currentTime, 0.1); 
            },
            play: function(f,t,d,v=0.1) { 
                if(!this.ctx)return; const o=this.ctx.createOscillator(),g=this.ctx.createGain(); o.type=t; o.frequency.value=f; 
                g.gain.setValueAtTime(v * VOLUMES.sfx, this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.01,this.ctx.currentTime+d); 
                o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(this.ctx.currentTime+d); 
            }, 
            coin:()=>AudioSys.play(600,'square',0.1), hit:()=>AudioSys.play(100,'sawtooth',0.3, 0.3), boost:()=>AudioSys.play(300,'square',0.5,0.1), 
            smash:()=>AudioSys.play(50,'square',0.2,0.5), heal:()=>AudioSys.play(600,'sine',0.5,0.2), fuel:()=>AudioSys.play(200,'sawtooth',0.3,0.1), 
            drill:()=>AudioSys.play(80,'square',0.3,0.2), 
            startMenuMusic: () => {
                AudioSys.unlock();
                if(AudioSys.bgMusic) { AudioSys.bgMusic.pause(); AudioSys.bgMusic.currentTime = 0; }
                if(AudioSys.menuMusic && AudioSys.menuMusic.paused) { 
                    AudioSys.menuMusic.volume = VOLUMES.music; AudioSys.menuMusic.play().catch(e=>{}); 
                }
            },
            startGameMusic: () => {
                AudioSys.unlock();
                if(AudioSys.menuMusic) { AudioSys.menuMusic.pause(); AudioSys.menuMusic.currentTime = 0; }
                if(AudioSys.bgMusic) { 
                    AudioSys.bgMusic.volume = VOLUMES.music; 
                    AudioSys.bgMusic.currentTime = 0; 
                    AudioSys.bgMusic.play().catch(e => {}); 
                }
            },
            gameOver:()=>{ 
                AudioSys.play(60,'sawtooth',1.0, 0.5); 
                if(AudioSys.engineGain) AudioSys.engineGain.gain.setTargetAtTime(0, AudioSys.ctx.currentTime, 0.1); 
                if(AudioSys.bgMusic) { AudioSys.bgMusic.pause(); }
            },
            pauseMusic: (p) => { if(AudioSys.bgMusic) { p ? AudioSys.bgMusic.pause() : AudioSys.bgMusic.play(); } },
            updateMusicVolume: () => { if(AudioSys.bgMusic) AudioSys.bgMusic.volume = VOLUMES.music; if(AudioSys.menuMusic) AudioSys.menuMusic.volume = VOLUMES.music; }
        };

        window.addEventListener('touchstart', () => AudioSys.unlock(), {once:true});
        window.addEventListener('click', () => AudioSys.unlock(), {once:true});

        function switchScreen(id) {
            document.querySelectorAll('.overlay-screen').forEach(s => s.classList.add('hidden'));
            document.getElementById(id).classList.remove('hidden');
            selectedBtnIndex = 0; 
            updateMenuSelection();
        }

        let selectedBtnIndex = 0;
        function updateMenuSelection() {
            const activeScreen = document.querySelector('.overlay-screen:not(.hidden)');
            if(!activeScreen) return;
            const buttons = activeScreen.querySelectorAll('.btn');
            buttons.forEach((b, i) => {
                if(i === selectedBtnIndex) b.classList.add('selected');
                else b.classList.remove('selected');
            });
        }

        document.addEventListener('keydown', e => {
            if(!isPlaying || isPaused || document.querySelector('.overlay-screen:not(.hidden)')) {
                const activeScreen = document.querySelector('.overlay-screen:not(.hidden)');
                if(activeScreen) {
                    const buttons = activeScreen.querySelectorAll('.btn');
                    if(buttons.length > 0) {
                        if(e.key === 'ArrowUp') { e.preventDefault(); selectedBtnIndex = (selectedBtnIndex - 1 + buttons.length) % buttons.length; updateMenuSelection(); } 
                        else if(e.key === 'ArrowDown') { e.preventDefault(); selectedBtnIndex = (selectedBtnIndex + 1) % buttons.length; updateMenuSelection(); } 
                        else if(e.key === 'Enter') { e.preventDefault(); AudioSys.unlock(); buttons[selectedBtnIndex].click(); }
                    }
                }
            }
        });

        function openGuide() { switchScreen('guide-screen'); }
        function closeGuide() { switchScreen('start-screen'); }

        function openAudioSettings() { 
            switchScreen('audio-screen'); 
            const slider = document.getElementById('res-slider');
            if(renderScale === 0) {
                slider.value = 0;
                document.getElementById('res-val').innerText = "AUTO (" + window.devicePixelRatio.toFixed(1) + "x)";
            } else {
                slider.value = renderScale * 100;
                document.getElementById('res-val').innerText = renderScale.toFixed(1) + "x";
            }
        }
        function closeAudioSettings() { switchScreen('start-screen'); }
        function updateAudioSettings(type, val) {
            const pct = parseInt(val); const decimal = pct / 100;
            if(type === 'music') { VOLUMES.music = decimal; document.getElementById('vol-music-val').innerText = pct + '%'; AudioSys.updateMusicVolume(); } 
            else if (type === 'engine') { VOLUMES.engine = decimal; document.getElementById('vol-engine-val').innerText = pct + '%'; } 
            else if (type === 'sfx') { VOLUMES.sfx = decimal; document.getElementById('vol-sfx-val').innerText = pct + '%'; }
        }

function openSkinMenu() {
            switchScreen('skin-screen');
            previewSkinIndex = currentSkinIndex;
            
            initGarage3D();
            updateGaragePlane();
            isGarageOpen = true;
            animateGarage();
            
            updateSkinPreview();
        }

        function closeSkinMenu() {
            isGarageOpen = false;
            switchScreen('start-screen');
        }

        function changeSkin(dir) {
            previewSkinIndex += dir;
            if(previewSkinIndex < 0) previewSkinIndex = SKINS.length - 1;
            if(previewSkinIndex >= SKINS.length) previewSkinIndex = 0;
            
            updateSkinPreview();
            updateGaragePlane();
        }

        function updateSkinPreview() {
            const skin = SKINS[previewSkinIndex];
            document.getElementById('skin-name').innerText = skin.name;
            let modelName = "STANDARD MK-1";
            if(skin.model === 'B') modelName = "INTERCEPTOR CLASS";
            if(skin.model === 'C') modelName = "HEAVY BOMBER";
            document.getElementById('skin-model-label').innerText = modelName;
            
            const btn = document.getElementById('select-skin-btn');
            if(previewSkinIndex === currentSkinIndex) {
                btn.innerText = "Ã‰QUIPÃ‰";
                btn.style.background = "#555";
                btn.style.color = "#FFF";
            } else {
                btn.innerText = "CHOISIR";
                btn.style.background = "#00FF00";
                btn.style.color = "#000";
            }
        }

        function selectSkin() {
            currentSkinIndex = previewSkinIndex;
            AudioSys.coin(); 
            createVoxelPlane();
            updateSkinPreview(); 
        }

        function updateResolution(val) {
            if(val == 0 || val < 50) {
                renderScale = 0;
                document.getElementById('res-val').innerText = "AUTO";
            } else {
                renderScale = val / 100;
                document.getElementById('res-val').innerText = renderScale.toFixed(1) + "x";
            }
            if(renderer) {
                const ratio = renderScale === 0 ? Math.min(window.devicePixelRatio, 3) : renderScale;
                renderer.setPixelRatio(ratio);
            }
        }

        let inputSensitivity = 1.0;
        function updateSensitivity(val) {
            inputSensitivity = parseFloat(val);
            document.getElementById('sens-val').innerText = inputSensitivity.toFixed(2);
        }

        const CONFIG = { 
            baseSpeed: 1.8, maxBoostSpeed: 4.5, 
            chunkSize: 100, chunkCount: isMobile ? 12 : 30,
            biomes: [
                { name: 'Sand', base: 0xA0522D, var1: 0xF4A460, var2: 0xD2B48C, fog: 0xffbd55 }, 
                { name: 'Cyan', base: 0x004d40, var1: 0x00695c, var2: 0x00897b, fog: 0x00e5ff }, 
                { name: 'Neon', base: 0x4b0082, var1: 0x6a1b9a, var2: 0x8e24aa, fog: 0xff00cc }, 
                { name: 'Mars', base: 0x3e2723, var1: 0x5d4037, var2: 0x8d6e63, fog: 0xff5722 }, 
                { name: 'Toxic', base: 0x1b5e20, var1: 0x66bb6a, var2: 0xa5d6a7, fog: 0x00ff00 }, 
                { name: 'Deep', base: 0x000022, var1: 0x1a237e, var2: 0x304ffe, fog: 0x536dfe }, 
                { name: 'Gold', base: 0x3e2723, var1: 0xffd700, var2: 0xffecb3, fog: 0xffca28 }  
            ],
            biomeLength: 2000,
            transitionLength: 500, 
            colors: {
                birdBody: 0x4A4A4A, birdWing: 0xB87333, 
                cloud: 0xFFFFFF, rocket: 0xFF00FF, wrench: 0xC0C0C0, 
                fuel: 0xFF0000, missile: 0x00FFFF, 
                drill: 0x607D8B, 
                balloonMain: 0x8B4513, balloonSec: 0xF5DEB3,   
                ufoMain: 0x333333, ufoLight: 0x00FF00, alienLaser: 0xFF0000,
                bridge: 0x8B4513, bridgeRope: 0xD2691E
            }
        };

        // --- CONFIGURATION DES SKINS ---
        const SKINS = [
            // MODÃˆLE A : Le Standard (Ã‰quilibrÃ©)
            { name: "CLASSIC MK-1", model: 'A', colors: { main: 0xFFFFFF, sec: 0xD32F2F, glass: 0x88CCFF, glow: 0x00FFFF } },
            { name: "NIGHT OPS",    model: 'A', colors: { main: 0x333333, sec: 0x111111, glass: 0xFF0000, glow: 0xFF0000 } },
            { name: "GOLDEN AGE",   model: 'A', colors: { main: 0xFFD700, sec: 0x222222, glass: 0x00FFFF, glow: 0xFFD700 } },
            
            // MODÃˆLE B : L'Intercepteur (Rapide, pointu, ailes inversÃ©es)
            { name: "SPEED DEMON",  model: 'B', colors: { main: 0xFF0055, sec: 0xFFFFFF, glass: 0x00FFFF, glow: 0xFF0055 } },
            { name: "CYBER PUNK",   model: 'B', colors: { main: 0x00FFFF, sec: 0xFF00FF, glass: 0xFFFF00, glow: 0x00FF00 } },
            { name: "VOID RUNNER",  model: 'B', colors: { main: 0x220044, sec: 0x000000, glass: 0xFFFFFF, glow: 0x8A2BE2 } },

            // MODÃˆLE C : Le Bombardier (Lourd, large, double queue)
            { name: "HEAVY METAL",  model: 'C', colors: { main: 0x5D4037, sec: 0x3E2723, glass: 0xFFA500, glow: 0xFFA500 } },
            { name: "ARCTIC FOX",   model: 'C', colors: { main: 0xDDEEFF, sec: 0x88CCFF, glass: 0x0000FF, glow: 0x00FFFF } },
            { name: "TOXIC HAZARD", model: 'C', colors: { main: 0x112211, sec: 0x00FF00, glass: 0x00FF00, glow: 0x00FF00 } }
        ];

        let currentSkinIndex = 0;
        let previewSkinIndex = 0;
        
        let scene, camera, renderer, plane, propeller, sunMesh, drillMesh, starField;
        let terrainChunks = [], objects = [], particles = [];
        let score = 0, health = 100, energy = 100, gameSpeed = CONFIG.baseSpeed, distance = 0;
        let playerLogicalX = 0;
        let isPlaying = false, isPaused = false, frameCount = 0;
        
        let controlMode = 'touch'; 
        let mouseX = 0, mouseY = 0; 
        let joystickInput = { x: 0, y: 0 };
        let keyInput = { x: 0, y: 0 };
        let isBoosting = false;
        
        let invincibleTimer = 0; const INVINCIBLE_DURATION = 400; 
        let birdShieldTimer = 0; const BIRD_SHIELD_DURATION = 600; 
        let drillTimer = 0; const DRILL_DURATION = 600;
        let comboCount = 0; let comboTimer = 0; let currentComboMultiplier = 1.0;
        let overdriveLevel = 0;
        const COMBO_WINDOW = 600;
        let bounceForce = 0, wallHitTimer = 0, isInputLocked = false;
        let screenShake = 0, isIntro = false, introTimer = 0;
        const INTRO_DURATION_MS = 3000; 
        let introStartTime = 0;
        
        let simplex;

        function getScores() { const s = localStorage.getItem('planeRushFinalScores'); let scores = s ? JSON.parse(s) : []; return scores.map(sc => { if(!sc.name) sc.name = "ANONYME"; return sc; }); }
        function saveScore(name, ns, dist) { let s = getScores(); s.push({name: name.toUpperCase(), score: ns, dist: dist}); s.sort((a,b) => b.score - a.score); s = s.slice(0,5); localStorage.setItem('planeRushFinalScores', JSON.stringify(s)); return s; }
        function isHighScore(ns) { let s = getScores(); if (s.length < 5) return true; return ns > s[s.length-1].score; }
        function updateLeaderboardUI() { const s = getScores(); while(s.length < 5) s.push({name: "---", score:0, dist:0}); const html = s.map((v,i) => `<div class="score-entry"><span>#${i+1} ${v.name}</span><span>${v.score}</span></div>`).join(''); document.getElementById('lb-start').innerHTML = html; document.getElementById('lb-end').innerHTML = html; }
        function submitHighScore() { let name = document.getElementById('player-name-input').value; if(!name || name.trim() === "") name = "PILOTE"; saveScore(name, score, distance); updateLeaderboardUI(); document.getElementById('highscore-form').classList.add('hidden'); }

        function lerp(start, end, t) { return start * (1 - t) + end * t; }
        function lerpColor(c1, c2, alpha) {
            const r1 = (c1 >> 16) & 255, g1 = (c1 >> 8) & 255, b1 = c1 & 255;
            const r2 = (c2 >> 16) & 255, g2 = (c2 >> 8) & 255, b2 = c2 & 255;
            const r = Math.round(r1 + (r2 - r1) * alpha);
            const g = Math.round(g1 + (g2 - g1) * alpha);
            const b = Math.round(b1 + (b2 - b1) * alpha);
            return (r << 16) | (g << 8) | b;
        }

        function pseudoRandom(seed) { let x = Math.sin(seed++) * 10000; return x - Math.floor(x); }

        function getCurrentBiomeColors(z) {
            const d = Math.abs(z);
            const chunkIndex = Math.floor(d / CONFIG.biomeLength);
            const biomeIdx1 = Math.floor(pseudoRandom(chunkIndex) * CONFIG.biomes.length);
            const biomeIdx2 = Math.floor(pseudoRandom(chunkIndex + 1) * CONFIG.biomes.length);
            
            const localDist = d % CONFIG.biomeLength;
            if (localDist > (CONFIG.biomeLength - CONFIG.transitionLength)) {
                const transProgress = (localDist - (CONFIG.biomeLength - CONFIG.transitionLength)) / CONFIG.transitionLength;
                const b1 = CONFIG.biomes[biomeIdx1]; const b2 = CONFIG.biomes[biomeIdx2];
                return {
                    base: lerpColor(b1.base, b2.base, transProgress), var1: lerpColor(b1.var1, b2.var1, transProgress),
                    var2: lerpColor(b1.var2, b2.var2, transProgress), fog: lerpColor(b1.fog, b2.fog, transProgress)
                };
            } else { return CONFIG.biomes[biomeIdx1]; }
        }

function getTrackOffset(z) {
    const hudDistance = -z * 0.1; 
    
    if (hudDistance < 1000) return 0;

    let transition = 1.0;
    if (hudDistance < 1500) transition = (hudDistance - 1000) / 500;

    if(simplex) {
        const curve = simplex.noise2D(0, z * 0.0002) * 250;
        const startOffset = simplex.noise2D(0, -10000 * 0.0002) * 250;
        
        return (curve - startOffset) * transition;
    }
    return 0;
}

       function getTerrainHeight(x, z) {
            if(!simplex) return -12;
            let noise = simplex.noise2D(x * 0.02, z * 0.02); 
            let h = -12; 
            
            if(Math.abs(x) > 30) { 
                let canyonH = Math.max(0, noise * 40 + (Math.abs(x) - 30) * 1.5); 
                h += Math.floor(canyonH / 4) * 4; 
            } 
            return h;
        }

        function getSpawnThresholds(dist) {

            let maxEnemyProb = 0.50; 
            let itemProbTotal = 0.25; 

            let enemyMult = 1.0;
            if(dist >= 2500) {
                let t = (dist - 2500) / 7500;
                if(t > 1) t = 1;
                enemyMult = 1.0 + (0.6 * t); 
            }

            let baseEnemy = 0.35 * enemyMult; 
            if(baseEnemy > 0.55) baseEnemy = 0.55;

            let pBird = baseEnemy / 2;
            let pBalloon = baseEnemy / 2;
            let pOneItem = itemProbTotal / 5;

            return {
                bird: pBird,
                balloon: pBird + pBalloon,
                wrench: pBird + pBalloon + pOneItem,
                fuel: pBird + pBalloon + (pOneItem * 2),
                rocket: pBird + pBalloon + (pOneItem * 3),
                missile: pBird + pBalloon + (pOneItem * 4),
                drill: pBird + pBalloon + (pOneItem * 5)
            };
        }

        function spawnFloatingText(text, position, color) {
            const el = document.createElement('div');
            el.className = 'floating-text';
            el.innerText = text;
            el.style.color = color;
            
            const vec = position.clone();
            vec.project(camera);
            
            const x = (vec.x * .5 + .5) * window.innerWidth;
            const y = (-(vec.y * .5) + .5) * window.innerHeight;
            
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            
            document.getElementById('floating-layer').appendChild(el);
            setTimeout(() => el.remove(), 800);
        }

        function init() {
            initDailyQuests();
            AudioSys.init(); if(typeof SimplexNoise !== 'undefined') simplex = new SimplexNoise();
            updateLeaderboardUI(); switchScreen('start-screen'); 

            scene = new THREE.Scene(); scene.fog = new THREE.Fog(CONFIG.biomes[0].fog, 600, 2500); 
            let camZ = 32; if(window.innerHeight > window.innerWidth) camZ = 45; 
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 3000); camera.position.set(0, 8, 25);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight); 
            const ratio = renderScale === 0 ? Math.min(window.devicePixelRatio, 3) : renderScale; renderer.setPixelRatio(ratio);
            
            renderer.shadowMap.enabled = true; 
            renderer.shadowMap.type = isMobile ? THREE.BasicShadowMap : THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const hemiLight = new THREE.HemisphereLight(0x8A2BE2, 0x606080, 0.9); 
            scene.add(hemiLight);

            const ambient = new THREE.AmbientLight(0xFFFFFF, 0.4); 
            scene.add(ambient);

            const sunLight = new THREE.DirectionalLight(0xFFD700, 1.5); 
            
            sunLight.position.set(-30, 60, -100); 
            
            sunLight.castShadow = true; 
            const shadowSize = isMobile ? 1024 : 2048;
            sunLight.shadow.mapSize.width = shadowSize; 
            sunLight.shadow.mapSize.height = shadowSize;
            
            sunLight.shadow.mapSize.width = 2048; 
            sunLight.shadow.mapSize.height = 2048;
            const d = 150;
            sunLight.shadow.camera.left = -d;
            sunLight.shadow.camera.right = d;
            sunLight.shadow.camera.top = d;
            sunLight.shadow.camera.bottom = -d;
            sunLight.shadow.camera.near = 0.1;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.bias = -0.0005; 
            
            scene.add(sunLight);
            
            const sunGeo = new THREE.CircleGeometry(80, 32); 
            const sunMat = new THREE.MeshBasicMaterial({ 
                color: 0xFFD700, 
                fog: false, 
                depthWrite: false, 
                side: THREE.DoubleSide 
            }); 
            sunMesh = new THREE.Mesh(sunGeo, sunMat); 
            
            sunMesh.renderOrder = -999; 
            
            scene.add(sunMesh);
            
            createVoxelPlane(); createStarField();
            for(let i=0; i<CONFIG.chunkCount; i++) terrainChunks.push(createChunk(-i * CONFIG.chunkSize));
            
            setupMobileControls(); setupPCControls();
            window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; if(window.innerHeight > window.innerWidth) camera.position.z = 45; else camera.position.z = 25; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
            AudioSys.startMenuMusic(); animate();
        }

        function setupMobileControls() {
            const stick = document.getElementById('joystick-stick'); const zone = document.getElementById('joystick-zone'); const base = document.getElementById('joystick-base'); const boost = document.getElementById('boost-btn'); let stickId = null; const maxRadius = 40;
            const updateStick = (clientX, clientY) => { const rect = base.getBoundingClientRect(); const centerX = rect.left + rect.width / 2; const centerY = rect.top + rect.height / 2; let dx = clientX - centerX; let dy = clientY - centerY; const dist = Math.sqrt(dx*dx + dy*dy); if (dist > maxRadius) { const ratio = maxRadius / dist; dx *= ratio; dy *= ratio; } stick.style.transform = `translate(${dx}px, ${dy}px)`; joystickInput.x = dx / maxRadius; joystickInput.y = -(dy / maxRadius); };
            const handleTouchStart = (e) => { e.preventDefault(); const touch = e.changedTouches[0]; stickId = touch.identifier; updateStick(touch.clientX, touch.clientY); };
            const handleTouchMove = (e) => { e.preventDefault(); for(let i=0; i<e.changedTouches.length; i++){ if(e.changedTouches[i].identifier === stickId) { updateStick(e.changedTouches[i].clientX, e.changedTouches[i].clientY); break; } } };
            const handleTouchEnd = (e) => { e.preventDefault(); for(let i=0; i<e.changedTouches.length; i++){ if(e.changedTouches[i].identifier === stickId) { stickId = null; stick.style.transform = `translate(0px, 0px)`; joystickInput.x = 0; joystickInput.y = 0; break; } } };
            zone.addEventListener('touchstart', handleTouchStart, {passive: false}); zone.addEventListener('touchmove', handleTouchMove, {passive: false}); zone.addEventListener('touchend', handleTouchEnd, {passive: false});
            boost.addEventListener('touchstart', e => { e.preventDefault(); isBoosting = true; }, {passive: false}); boost.addEventListener('touchend', e => { e.preventDefault(); isBoosting = false; }, {passive: false});
        }

        function setupPCControls() {
            document.addEventListener('mousemove', e => { if(!isPaused && isPlaying && controlMode === 'mouse' && !isIntro) { if (document.pointerLockElement === document.body) { mouseX += e.movementX * 0.002; mouseY -= e.movementY * 0.002; mouseX = Math.max(-1, Math.min(1, mouseX)); mouseY = Math.max(-1, Math.min(1, mouseY)); } } });
            document.addEventListener('mousedown', (e) => { if(!isPaused && isPlaying && controlMode === 'mouse' && !isIntro) { if(document.pointerLockElement !== document.body) document.body.requestPointerLock(); if (e.button === 0 || e.button === 2) isBoosting = true; } });
            document.addEventListener('mouseup', () => { if(controlMode === 'mouse') isBoosting = false; });
            document.addEventListener('keydown', e => { if((e.key === "Tab" || e.key === "Escape") && isPlaying) { e.preventDefault(); togglePause(); } if(controlMode === 'keyboard' && isPlaying && !isPaused && !isIntro) { if(e.key === "ArrowUp" || e.key === "w" || e.key === "W") keyInput.y = 1; if(e.key === "ArrowDown" || e.key === "s" || e.key === "S") keyInput.y = -1; if(e.key === "ArrowLeft" || e.key === "a" || e.key === "A") keyInput.x = -1; if(e.key === "ArrowRight" || e.key === "d" || e.key === "D") keyInput.x = 1; if(e.key === " " || e.key === "Shift") isBoosting = true; } });
            document.addEventListener('keyup', e => { if(controlMode === 'keyboard') { if(e.key === "ArrowUp" || e.key === "w" || e.key === "W" || e.key === "ArrowDown" || e.key === "s" || e.key === "S") keyInput.y = 0; if(e.key === "ArrowLeft" || e.key === "a" || e.key === "A" || e.key === "ArrowRight" || e.key === "d" || e.key === "D") keyInput.x = 0; if(e.key === " " || e.key === "Shift") isBoosting = false; } });
        }

        function createStarField() {
            const starGeo = new THREE.BufferGeometry(); const starCount = 1000; const posArray = new Float32Array(starCount * 3);
            for(let i=0; i<starCount*3; i+=3) { posArray[i] = (Math.random() - 0.5) * 600; posArray[i+1] = Math.random() * 200 + 40; posArray[i+2] = (Math.random() - 0.5) * 1000 - 200; }
            starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const starMat = new THREE.PointsMaterial({color: 0xFFFFFF, size: 0.6, transparent: true, opacity: 0.7});
            starField = new THREE.Points(starGeo, starMat); scene.add(starField);
        }

        function createVoxelBox(w, h, d, color, x, y, z, emissive=false, opacity=1.0, castShadow=false) { 
    const geo = new THREE.BoxGeometry(w, h, d);
    
    const matType = emissive ? THREE.MeshPhongMaterial : THREE.MeshLambertMaterial;
    
    const mat = new matType({ 
        color: color, 
        flatShading: true, 
        emissive: emissive ? color : 0x000000, 
        emissiveIntensity: emissive ? 0.5 : 0, 
        transparent: opacity < 1.0, 
        opacity: opacity 
    });

    const mesh = new THREE.Mesh(geo, mat); 
    mesh.position.set(x, y, z); 
    
    mesh.castShadow = castShadow; 
    mesh.receiveShadow = true;

    if(opacity === 1.0 && !isMobile) { 
        const edges = new THREE.EdgesGeometry(geo); 
        const lineMat = new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.3, transparent: true }); 
        const line = new THREE.LineSegments(edges, lineMat); 
        mesh.add(line); 
    }
    
    return mesh;
}

        function buildPlaneModel(skinIdx) {
            const group = new THREE.Group();
            const skin = SKINS[skinIdx];
            const cols = skin.colors;
            const P_OPACITY = 1.0; 

            if (skin.model === 'A') {
                group.add(createVoxelBox(1.2, 1.2, 1.0, 0xCCCCCC, 0, 0, -3.5, false, P_OPACITY, false));
                group.add(createVoxelBox(1.8, 1.8, 1.5, cols.sec, 0, 0, -2.5, false, P_OPACITY, false));
                group.add(createVoxelBox(2.0, 2.0, 3.0, cols.main, 0, 0, -0.5, false, P_OPACITY, false));
                group.add(createVoxelBox(1.6, 1.6, 2.0, cols.sec, 0, 0, 2.0, false, P_OPACITY, false));
                group.add(createVoxelBox(1.4, 0.6, 1.0, cols.glass, 0, 1.1, -1.0, false, 0.7, false)); 
                group.add(createVoxelBox(1.6, 0.8, 1.5, cols.glass, 0, 1.2, 0.2, false, 0.7, false));
                
                const wingL = new THREE.Group();
                wingL.add(createVoxelBox(3.5, 0.4, 1.5, cols.main, -2.5, 0, 0, false, P_OPACITY, false)); 
                wingL.add(createVoxelBox(2.5, 0.3, 1.0, 0xCCCCCC, -5.0, 0, 0.5, false, P_OPACITY, false)); 
                wingL.add(createVoxelBox(0.2, 0.8, 1.5, cols.sec, -6.0, 0.5, 0.5, false, P_OPACITY, false)); 
                group.add(wingL);
                const wingR = new THREE.Group();
                wingR.add(createVoxelBox(3.5, 0.4, 1.5, cols.main, 2.5, 0, 0, false, P_OPACITY, false)); 
                wingR.add(createVoxelBox(2.5, 0.3, 1.0, 0xCCCCCC, 5.0, 0, 0.5, false, P_OPACITY, false));
                wingR.add(createVoxelBox(0.2, 0.8, 1.5, cols.sec, 6.0, 0.5, 0.5, false, P_OPACITY, false)); 
                group.add(wingR);
                
                group.add(createVoxelBox(0.4, 2.0, 1.5, cols.sec, 0, 1.5, 2.5, false, P_OPACITY, false));
                group.add(createVoxelBox(3.0, 0.3, 1.0, 0x333333, 0, 0.5, 2.8, false, P_OPACITY, false));
                group.add(createVoxelBox(0.5, 0.5, 1.0, 0x333333, 0.8, -0.8, 1.0, false, P_OPACITY, false));
                group.add(createVoxelBox(0.5, 0.5, 1.0, 0x333333, -0.8, -0.8, 1.0, false, P_OPACITY, false));
            }

            else if (skin.model === 'B') {
                group.add(createVoxelBox(0.6, 0.6, 2.0, 0x222222, 0, 0, -4.5, false, P_OPACITY, false));
                group.add(createVoxelBox(1.2, 1.0, 2.0, cols.sec, 0, 0, -2.5, false, P_OPACITY, false));
                group.add(createVoxelBox(1.6, 1.4, 4.0, cols.main, 0, 0, 0.5, false, P_OPACITY, false));
                group.add(createVoxelBox(1.0, 0.5, 2.0, cols.glass, 0, 0.9, -1.0, false, 0.8, false));
                
                const wingL = new THREE.Group();
                wingL.add(createVoxelBox(2.2, 0.2, 1.5, cols.main, -1.6, 0, 0.8, false, P_OPACITY, false));
                wingL.add(createVoxelBox(2.0, 0.2, 1.0, cols.sec, -3.2, 0.01, -0.2, false, P_OPACITY, false)); 
                group.add(wingL);

                const wingR = new THREE.Group();
                wingR.add(createVoxelBox(2.2, 0.2, 1.5, cols.main, 1.6, 0, 0.8, false, P_OPACITY, false));
                wingR.add(createVoxelBox(2.0, 0.2, 1.0, cols.sec, 3.2, 0.01, -0.2, false, P_OPACITY, false));
                group.add(wingR);

                group.add(createVoxelBox(0.2, 1.5, 1.5, cols.sec, -0.8, 1.0, 2.0, false, P_OPACITY, false));
                group.add(createVoxelBox(0.2, 1.5, 1.5, cols.sec, 0.8, 1.0, 2.0, false, P_OPACITY, false));
                group.add(createVoxelBox(1.0, 1.0, 0.5, cols.glow, 0, 0, 2.5, true, 1.0, false));
            }

            else if (skin.model === 'C') {
                group.add(createVoxelBox(2.5, 1.0, 1.0, 0x222222, 0, 0, -3.0, false, P_OPACITY, false));
                group.add(createVoxelBox(3.0, 1.5, 4.0, cols.main, 0, 0, -0.5, false, P_OPACITY, false));
                group.add(createVoxelBox(2.0, 0.6, 1.5, cols.glass, 0, 1.0, -1.5, false, 0.7, false));
                group.add(createVoxelBox(4.0, 0.5, 2.0, cols.main, -3.5, -0.2, 0, false, P_OPACITY, false));
                group.add(createVoxelBox(4.0, 0.5, 2.0, cols.main, 3.5, -0.2, 0, false, P_OPACITY, false));
                group.add(createVoxelBox(1.0, 1.0, 2.0, cols.sec, -3.0, 0.5, 0.5, false, P_OPACITY, false));
                group.add(createVoxelBox(1.0, 1.0, 2.0, cols.sec, 3.0, 0.5, 0.5, false, P_OPACITY, false));
                group.add(createVoxelBox(0.5, 0.5, 3.0, cols.main, -1.5, 0, 2.5, false, P_OPACITY, false));
                group.add(createVoxelBox(0.5, 0.5, 3.0, cols.main, 1.5, 0, 2.5, false, P_OPACITY, false));
                group.add(createVoxelBox(4.0, 0.4, 0.8, cols.sec, 0, 0.5, 4.0, false, P_OPACITY, false));
            }

            const prop = new THREE.Group();
            prop.add(createVoxelBox(0.8, 0.8, 0.5, 0x111111, 0, 0, 0, false, P_OPACITY, false)); 
            prop.add(createVoxelBox(7.0, 0.4, 0.1, 0x111111, 0, 0, 0, false, P_OPACITY, false)); 
            prop.add(createVoxelBox(0.4, 7.0, 0.1, 0x111111, 0, 0, 0, false, P_OPACITY, false)); 
            
            let propZ = -4.1;
            if(skin.model === 'B') propZ = -5.0; 
            if(skin.model === 'C') propZ = -3.6; 
            prop.position.set(0, 0, propZ);
            
            group.userData.propeller = prop;
            group.add(prop);

            const drill = new THREE.Group();
            drill.add(createVoxelBox(2.2, 2.2, 1.0, 0x555555, 0, 0, 0, false, P_OPACITY, false));
            drill.add(createVoxelBox(1.8, 1.8, 1.5, 0x888888, 0, 0, -1.2, false, P_OPACITY, false));
            drill.add(createVoxelBox(1.4, 1.4, 1.5, 0xAAAAAA, 0, 0, -2.7, false, P_OPACITY, false));
            drill.add(createVoxelBox(0.8, 0.8, 1.5, 0xFFFFFF, 0, 0, -4.2, false, P_OPACITY, false));
            drill.add(createVoxelBox(2.0, 0.4, 0.4, 0xFFFF00, 0, 0.9, -1.0, false, P_OPACITY, false));
            drill.add(createVoxelBox(1.5, 0.4, 0.4, 0xFFFF00, 0.7, 0, -2.5, false, P_OPACITY, false));
            drill.add(createVoxelBox(1.0, 0.3, 0.3, 0xFFFF00, 0, -0.5, -3.8, false, P_OPACITY, false));
            drill.position.set(0, 0, -3.5);
            drill.visible = false;
            
            group.userData.drill = drill;
            group.add(drill);

            return group;
        }

        function createVoxelPlane() {
            if(plane) scene.remove(plane);
            plane = buildPlaneModel(currentSkinIndex);
            
            propeller = plane.userData.propeller;
            drillMesh = plane.userData.drill;
            
            scene.add(plane);
        }

        function createVoxelTree(leafColor) {
            const group = new THREE.Group();
            const trunkColor = 0x443322;
            
            const variant = Math.floor(Math.random() * 3);

            if (variant === 0) { 
                group.add(createVoxelBox(1.2, 2.0, 1.2, trunkColor, 0, 1, 0));
                group.add(createVoxelBox(4.0, 1.5, 4.0, leafColor, 0, 2.0, 0, false, 1.0, true));
                group.add(createVoxelBox(3.0, 1.5, 3.0, leafColor, 0, 3.2, 0, false, 1.0, true));
                group.add(createVoxelBox(1.5, 1.5, 1.5, leafColor, 0, 4.4, 0, false, 1.0, true));
                group.add(createVoxelBox(0.5, 1.0, 0.5, leafColor, 0, 5.5, 0, false, 1.0, true));
            } 
            else if (variant === 1) { 
                group.add(createVoxelBox(1.5, 2.5, 1.5, trunkColor, 0, 1.2, 0));
                group.add(createVoxelBox(5.0, 2.0, 5.0, leafColor, 0, 3.0, 0, false, 1.0, true));
                group.add(createVoxelBox(5.5, 1.5, 5.5, leafColor, 0, 2.5, 0, false, 1.0, true)); 
                group.add(createVoxelBox(3.5, 1.5, 3.5, leafColor, 0, 4.2, 0, false, 1.0, true)); 
            }
            else { 
                group.add(createVoxelBox(0.8, 3.0, 0.8, trunkColor, 0, 1.5, 0));
                group.add(createVoxelBox(4.0, 0.8, 4.0, leafColor, 0, 3.5, 0, false, 1.0, true));
                group.add(createVoxelBox(0.5, 1.5, 0.5, leafColor, -1.5, 2.5, -1.5, false, 1.0, true));
                group.add(createVoxelBox(0.5, 2.0, 0.5, leafColor, 1.5, 2.2, 1.5, false, 1.0, true));
                group.add(createVoxelBox(0.5, 1.2, 0.5, leafColor, -1.5, 2.8, 1.5, false, 1.0, true));
                group.add(createVoxelBox(0.5, 1.8, 0.5, leafColor, 1.5, 2.4, -1.5, false, 1.0, true));
            }
            return group;
        }

        function createVoxelRock(rockColor) {
            const group = new THREE.Group();
            group.add(createVoxelBox(3.0, 1.5, 3.0, rockColor, 0, 0.7, 0));
            group.add(createVoxelBox(2.2, 1.5, 2.2, rockColor, 0.2, 1.8, 0.1));
            group.add(createVoxelBox(1.2, 1.2, 1.2, rockColor, -0.3, 2.8, -0.2));
            
            group.add(createVoxelBox(1.0, 0.8, 1.0, rockColor, 2.0, 0.4, 2.0));
            
            return group;
        }

        function createVoxelLake(biomeFogColor) {
            const group = new THREE.Group();
            
            group.add(createVoxelBox(7.5, 0.4, 6.5, 0x3E2723, 0, -0.2, 0, false, 1.0, false));

            const waterColor = 0x4488FF;
            group.add(createVoxelBox(6.5, 0.4, 5.5, waterColor, 0, 0.1, 0, false, 0.8, false));
            group.add(createVoxelBox(2.5, 0.4, 3.0, waterColor, 3.5, 0.1, 1.0, false, 0.8, false));
            group.add(createVoxelBox(3.5, 0.4, 2.0, waterColor, -2.5, 0.1, -2.5, false, 0.8, false));

            const reflectionColor = 0xAAFFFF; 
            group.add(createVoxelBox(1.0, 0.05, 1.0, reflectionColor, 1.5, 0.31, 1.0, true, 0.9, false));
            group.add(createVoxelBox(0.4, 0.05, 0.4, reflectionColor, -1.0, 0.31, -1.0, true, 0.9, false));
            group.add(createVoxelBox(0.2, 0.05, 0.6, reflectionColor, 2.5, 0.31, -0.5, true, 0.9, false));

            group.add(createVoxelBox(1.2, 0.1, 1.2, 0x44AA44, -1.5, 0.32, 1.5, false, 1.0, false));
            group.add(createVoxelBox(0.3, 0.3, 0.3, 0xFF69B4, -1.5, 0.5, 1.5, false, 1.0, false));

            group.add(createVoxelBox(1.2, 0.6, 1.2, 0x555555, 3.5, 0.2, 2.5, false, 1.0, false)); 
            group.add(createVoxelBox(1.0, 0.2, 1.0, 0x668844, 3.5, 0.6, 2.5, false, 1.0, false)); 

            const reedGreen = 0x556B2F;
            const reedBrown = 0x8B4513;
            const positions = [[3.8, 1.5], [4.2, 1.0], [-3.2, -3.0]];

            positions.forEach(pos => {
                group.add(createVoxelBox(0.1, 1.4, 0.1, reedGreen, pos[0], 0.6, pos[1], false, 1.0, false));
                group.add(createVoxelBox(0.25, 0.5, 0.25, reedBrown, pos[0], 1.2, pos[1], false, 1.0, false));
            });

            return group;
        }

function createChunk(zPos) {

    const geo = new THREE.PlaneGeometry(250, CONFIG.chunkSize, 50, 25); 
    geo.rotateX(-Math.PI/2);
    
    const pos = geo.attributes.position; 
    const colors = [];
    const biomeColors = getCurrentBiomeColors(zPos);
    
    const chunkGroup = new THREE.Group();
    
    for(let i=0; i<pos.count; i++) {
        let x = pos.getX(i); 
        let zLocal = pos.getZ(i);
        let zGlobal = zPos + zLocal; 
        
        let rawH = getTerrainHeight(x, zGlobal);
        pos.setY(i, Math.floor(rawH / 2) * 2);
        
        const curveOffset = getTrackOffset(zGlobal);
        pos.setX(i, x + curveOffset);

        let finalColor; 
        if (rawH > -8) finalColor = biomeColors.var2; 
        else if (rawH > -4) finalColor = biomeColors.var1; 
        else finalColor = biomeColors.base;
        let c = new THREE.Color(finalColor); 
        colors.push(c.r, c.g, c.b);

        if (Math.random() > 0.99 && Math.abs(x) < 35) {
            
            const typeRnd = Math.random();
            let decor;
            const finalDecorX = x + curveOffset; 
            const finalDecorY = Math.floor(rawH / 2) * 2;

            if (typeRnd > 0.95) { 
                decor = createVoxelLake(biomeColors.fog);
                decor.scale.set(1.5, 1.0, 1.5);
                decor.position.set(finalDecorX, finalDecorY - 0.2, zLocal); 
            } else {
                const isTree = Math.random() > 0.5;
                if(isTree) {
                    const leafCol = (Math.random() > 0.5) ? biomeColors.var1 : biomeColors.fog; 
                    decor = createVoxelTree(leafCol);
                    const s = 1.0 + Math.random() * 0.8; decor.scale.set(s, s, s);
                } else {
                    const rockCol = (Math.random() > 0.5) ? biomeColors.base : 0x333333;
                    decor = createVoxelRock(rockCol);
                    const s = 0.8 + Math.random() * 0.6; decor.scale.set(s, s, s);
                }
                decor.position.set(finalDecorX, finalDecorY, zLocal); 
            }
            decor.rotation.y = Math.random() * Math.PI * 2;
            chunkGroup.add(decor);
        }
    }
    
    geo.computeVertexNormals(); 
    geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    
    const mat = new THREE.MeshPhongMaterial({vertexColors: true, flatShading:true, shininess:0});
    const groundMesh = new THREE.Mesh(geo, mat); 
    groundMesh.receiveShadow = true; 
    
    const edges = new THREE.EdgesGeometry(geo, 15); 
    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, transparent:true, opacity:0.3 }));
    
    groundMesh.add(line);
    chunkGroup.add(groundMesh);
    
    chunkGroup.position.z = zPos;
    
    scene.add(chunkGroup); 
    return chunkGroup;
}

        function addGlow(group, colorHex) {
            const geo = new THREE.BoxGeometry(2.5, 2.5, 2.5);
            const mat = new THREE.MeshBasicMaterial({ color: colorHex, transparent: true, opacity: 0.4, wireframe: true });
            const aura = new THREE.Mesh(geo, mat); group.add(aura);
        }

       function createVoxelCloud() {
            const group = new THREE.Group(); 
            const col = CONFIG.colors.cloud; 
            group.add(createVoxelBox(4, 1.5, 3, col, 0, 0, 0, false, 0.8));
            group.add(createVoxelBox(2.5, 1.5, 2.5, col, -1.5, 0.5, 0.5, false, 0.8));
            group.add(createVoxelBox(2.5, 1.5, 2.5, col, 1.5, 0.8, -0.5, false, 0.8));
            group.add(createVoxelBox(2, 1, 2, col, 0, 1.2, 0, false, 0.8));
            
            return group;
        }

     function createAlienLaserUnit() {
            const group = new THREE.Group();
            
            group.add(createVoxelBox(10, 1, 10, CONFIG.colors.ufoMain, 0, 0, 0));
            group.add(createVoxelBox(7, 1.5, 7, 0x555555, 0, 0.5, 0));
            const dome = createVoxelBox(4, 2, 4, CONFIG.colors.ufoLight, 0, 1.5, 0, true);
            dome.material.opacity = 0.8;
            group.add(dome);
            
            group.add(createVoxelBox(1, 2, 1, 0x880000, 2, -1, 2));
            group.add(createVoxelBox(1, 2, 1, 0x880000, -2, -1, -2));
            group.add(createVoxelBox(1, 2, 1, 0x880000, 2, -1, -2));
            group.add(createVoxelBox(1, 2, 1, 0x880000, -2, -1, 2));

            const beamGeo = new THREE.BoxGeometry(6, 200, 6); 
            const beamMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.alienLaser, transparent: true, opacity: 0.5 });
            const beam = new THREE.Mesh(beamGeo, beamMat);
            beam.position.set(0, -100, 0);
            beam.userData = { isBeam: true };
            
            const coreGeo = new THREE.BoxGeometry(2, 200, 2);
            const coreMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.8 });
            const coreBeam = new THREE.Mesh(coreGeo, coreMat);
            beam.add(coreBeam);
            
            group.add(beam);
            return group;
        }

       function createBridge() {
            const group = new THREE.Group();
            
            for(let x=-32; x<=32; x+=2.0) { 
                let y = (x*x) / 180; 
                
                const plankW = 1.8 + Math.random() * 0.4;
                group.add(createVoxelBox(1.8, 0.3, plankW, CONFIG.colors.bridge, x, y, 0));
                
                const ropeY = y + 1.2;
                group.add(createVoxelBox(2.2, 0.3, 0.3, CONFIG.colors.bridgeRope, x, ropeY, -1.2)); 
                group.add(createVoxelBox(2.2, 0.3, 0.3, CONFIG.colors.bridgeRope, x, ropeY, 1.2));  
                
                if (Math.abs(x) % 4 < 1) {
                    group.add(createVoxelBox(0.1, 1.2, 0.1, 0x553311, x, y + 0.6, -1.2));
                    group.add(createVoxelBox(0.1, 1.2, 0.1, 0x553311, x, y + 0.6, 1.2));
                }
            }
            
            const anchorY = (32*32)/180;
            group.add(createVoxelBox(4, 4, 4, 0x332211, -34, anchorY, 0));
            group.add(createVoxelBox(4, 4, 4, 0x332211, 34, anchorY, 0));

            return group;
        }

function spawnObject() {
            if (isIntro) return;
            const thresholds = getSpawnThresholds(distance);
            const r = Math.random(); 
            let type = 'cloud';
            
            const spawnZ = plane.position.z - 400;
            const trackCenter = getTrackOffset(spawnZ);

            if (distance > 1500 && Math.random() < 0.15) {
                const m = createAlienLaserUnit();
                let relX = (Math.random()-0.5) * 66; 
                
                m.userData = { type: 'alien_laser', baseScale: 1.0, relativeX: relX };
                m.position.set(trackCenter + relX, 50, spawnZ);
                
                scene.add(m); objects.push(m);
                return;
            }
            if (distance > 1500 && Math.random() < 0.10) {
                const m = createBridge();

                m.userData = { type: 'bridge', baseScale: 1.0, relativeX: 0 }; 
                m.position.set(trackCenter, 5, spawnZ);
                
                scene.add(m); objects.push(m);
                return;
            }


            if(r < thresholds.bird) type = 'bird'; 
            else if(r < thresholds.balloon) type = 'balloon'; 
            else if(r < thresholds.wrench) type = 'wrench'; 
            else if(r < thresholds.fuel) type = 'fuel'; 
            else if(r < thresholds.rocket) type = 'rocket'; 
            else if(r < thresholds.missile) type = 'missile'; 
            else if(r < thresholds.drill) type = 'drill'; 
            else type = 'cloud'; 

            let m; 
            let baseScale = 1.3; 

            if(type === 'cloud') { 
                m = createVoxelCloud(); 
                baseScale = 1.0 + Math.random() * 0.5; 
                m.userData = {type:'cloud', baseScale: baseScale, id: Math.random() * 100}; 
            }
            else {
                m = new THREE.Group();
                if(type==='bird') {
                     const body = new THREE.Group();
                    body.add(createVoxelBox(1.8, 1.2, 2.5, CONFIG.colors.birdBody, 0, 0, 0)); 
                    body.add(createVoxelBox(1.4, 0.8, 2.0, 0x333333, 0, 0.8, -0.2)); 
                    const head = new THREE.Group();
                    head.add(createVoxelBox(1.0, 1.0, 1.2, CONFIG.colors.birdBody, 0, 0, 0)); 
                    head.add(createVoxelBox(0.8, 0.4, 1.0, 0xFFD700, 0, -0.2, -1.0));
                    head.add(createVoxelBox(0.3, 0.3, 0.3, 0x00FFFF, 0.4, 0.3, -0.5, true)); 
                    head.add(createVoxelBox(0.3, 0.3, 0.3, 0x00FFFF, -0.4, 0.3, -0.5, true)); 
                    head.position.set(0, 0.4, -1.8);
                    body.add(head);
                    body.add(createVoxelBox(1.2, 0.2, 1.5, 0x333333, 0, 0.5, 1.8));
                    const g1=new THREE.Group(); 
                    g1.add(createVoxelBox(3.0, 0.3, 1.8, CONFIG.colors.birdWing, -1.5, 0, 0));
                    g1.add(createVoxelBox(2.5, 0.2, 1.2, 0x333333, -2.5, 0.2, 0.3));
                    g1.add(createVoxelBox(1.5, 0.2, 0.8, 0xFFD700, -3.5, 0.1, 0.5));
                    g1.position.set(-0.8, 0.4, 0);
                    const g2=new THREE.Group(); 
                    g2.add(createVoxelBox(3.0, 0.3, 1.8, CONFIG.colors.birdWing, 1.5, 0, 0));
                    g2.add(createVoxelBox(2.5, 0.2, 1.2, 0x333333, 2.5, 0.2, 0.3));
                    g2.add(createVoxelBox(1.5, 0.2, 0.8, 0xFFD700, 3.5, 0.1, 0.5));
                    g2.position.set(0.8, 0.4, 0);
                    m.add(body, g1, g2); 
                    
                    m.rotation.y = Math.PI; 
                    
                    m.userData = {wings:[g1, g2], dead: false}; 
                    baseScale = 1.3; 
                    if (Math.random() < 0.1) { m.userData.isMoving = true; m.userData.phase = Math.random() * Math.PI; }
                }
                else if(type==='balloon') {
                    const bMain = CONFIG.colors.balloonMain;
                    const bSec = CONFIG.colors.balloonSec;
                    m.add(createVoxelBox(5.0, 3.0, 5.0, bMain, 0, 3, 0)); 
                    m.add(createVoxelBox(4.0, 4.0, 4.0, bSec, 0, 3, 0)); 
                    m.add(createVoxelBox(3.0, 5.0, 3.0, bMain, 0, 3, 0)); 
                    m.add(createVoxelBox(2.0, 1.5, 2.0, 0x333333, 0, -1.5, 0)); 
                    m.add(createVoxelBox(1.2, 1.2, 1.2, 0x111111, 0, -2.2, 0)); 
                    m.add(createVoxelBox(0.4, 0.4, 0.4, 0xFF0000, 0, -2.5, 0.8, true)); 
                    const ropeCol = 0xDDDDDD;
                    m.add(createVoxelBox(0.1, 3.5, 0.1, ropeCol, -1.5, 0.5, -1.5));
                    m.add(createVoxelBox(0.1, 3.5, 0.1, ropeCol, 1.5, 0.5, 1.5));
                    m.add(createVoxelBox(0.1, 3.5, 0.1, ropeCol, -1.5, 0.5, 1.5));
                    m.add(createVoxelBox(0.1, 3.5, 0.1, ropeCol, 1.5, 0.5, -1.5));
                    baseScale = 1.0; 
                }
                else if(type==='fuel') {
                    m.add(createVoxelBox(2.0, 2.5, 1.0, CONFIG.colors.fuel, 0, 0, 0)); 
                    m.add(createVoxelBox(0.5, 0.5, 0.5, 0x333333, 0, 1.5, -0.3));
                    m.add(createVoxelBox(1.5, 0.4, 0.4, 0xAA0000, 0, 1.4, 0)); 
                    m.add(createVoxelBox(0.4, 1.4, 0.4, 0xAA0000, -0.6, 0.8, 0));
                    m.add(createVoxelBox(1.2, 0.4, 1.2, 0xFFFFFF, 0, 0, 0, true));
                    m.add(createVoxelBox(0.4, 1.2, 1.2, 0xFFFFFF, 0, 0, 0, true));
                    addGlow(m, 0xFF2200); 
                }
                else if(type==='missile') {
                    const shGroup = new THREE.Group();
                    shGroup.add(createVoxelBox(1.5, 1.5, 0.5, 0x333399, 0, 0, 0.2));
                    shGroup.add(createVoxelBox(0.8, 0.8, 0.8, 0xFFFFFF, 0, 0, 0.5, true));
                    shGroup.add(createVoxelBox(3.0, 3.5, 0.2, 0x0000FF, 0, 0, 0, false, 0.6));
                    shGroup.add(createVoxelBox(2.5, 3.0, 0.2, 0x0088FF, 0, 0, -0.2, false, 0.7));
                    shGroup.add(createVoxelBox(2.0, 2.5, 0.2, 0x00FFFF, 0, 0, -0.4, true, 0.8));
                    m.add(shGroup); 
                    addGlow(m, 0x00FFFF); 
                }
                else if(type==='rocket') {
                    m.add(createVoxelBox(1.0, 1.0, 3.5, 0xFF00FF, 0, 0, 0)); 
                    m.add(createVoxelBox(0.8, 0.8, 1.5, 0xFFFFFF, 0, 0.4, -0.5));
                    m.add(createVoxelBox(0.7, 0.7, 1.0, 0xFFFFFF, 0, 0, -2.0));
                    m.add(createVoxelBox(1.4, 1.4, 0.8, 0x550055, 0, 0, 1.8));
                    m.add(createVoxelBox(1.0, 1.0, 0.5, 0xFFFF00, 0, 0, 2.3, true));
                    m.add(createVoxelBox(3.0, 0.2, 1.2, 0x00FFFF, 0, 0, 1.2));
                    m.add(createVoxelBox(0.2, 3.0, 1.2, 0x00FFFF, 0, 0, 1.2));
                    addGlow(m, 0xFF00FF); 
                }
                else if(type==='wrench') {
                    m.add(createVoxelBox(0.8, 2.5, 0.5, 0x444444, 0, -1.0, 0));
                    m.add(createVoxelBox(1.0, 1.5, 0.6, 0x222222, 0, -1.5, 0));
                    m.add(createVoxelBox(2.2, 1.2, 0.7, 0xAAAAAA, 0, 1.2, 0)); 
                    m.add(createVoxelBox(0.6, 1.5, 0.7, 0xCCCCCC, -1.0, 2.0, 0));
                    m.add(createVoxelBox(0.6, 1.5, 0.7, 0xCCCCCC, 1.0, 2.0, 0));
                    m.add(createVoxelBox(0.4, 0.8, 0.8, 0x00FF00, 0, 0.5, 0, true));
                    m.rotation.z = Math.PI / 4; 
                    addGlow(m, 0x00FF00); 
                }
                else if(type==='drill') {
                    m.add(createVoxelBox(1.8, 2.0, 1.8, 0x333333, 0, -0.5, 0)); 
                    m.add(createVoxelBox(1.6, 0.8, 1.6, 0x666666, 0, 0.8, 0));
                    m.add(createVoxelBox(1.2, 0.8, 1.2, 0x996633, 0, 1.5, 0));
                    m.add(createVoxelBox(0.8, 1.0, 0.8, 0xFF8C00, 0, 2.2, 0, true));
                    m.add(createVoxelBox(0.4, 0.6, 0.4, 0xFFFF00, 0, 2.9, 0, true));
                    addGlow(m, 0xFF8C00); 
                }

                if(!m.userData) m.userData = {}; 
                m.userData.type = type; 
                if(!m.userData.baseScale) m.userData.baseScale = baseScale;
            }
            
            let spawnX = (Math.random()-0.5) * 60; 
            const h1 = getTerrainHeight(spawnX, spawnZ); 
            const h2 = getTerrainHeight(spawnX - 2, spawnZ); 
            const h3 = getTerrainHeight(spawnX + 2, spawnZ);
            const safeH = Math.max(h1, h2, h3); 
            
            let spawnY = Math.max(safeH + 4, (Math.random() * 10) - 2);

            if(type === 'balloon' || (type === 'cloud' && Math.random() > 0.5)) { 
                spawnY = safeH + 22; 
                spawnX = (Math.random()-0.5) * 32; 
            }

            m.userData.relativeX = spawnX; 
            m.userData.baseRelativeX = spawnX; 

            m.position.set(trackCenter + spawnX, spawnY, spawnZ); 
            m.scale.set(baseScale, baseScale, baseScale); 
            m.userData.initialX = trackCenter + spawnX; 
            
            scene.add(m); objects.push(m);
        }

const SHARED_PARTICLE_GEO = new THREE.BoxGeometry(0.8, 0.8, 0.8);

function spawnParticles(pos, c, count=6) { 
    const finalCount = isMobile ? Math.ceil(count / 2) : count;

    for(let i=0; i<finalCount; i++){ 
        const mat = new THREE.MeshBasicMaterial({ color: c }); 
        const m = new THREE.Mesh(SHARED_PARTICLE_GEO, mat); 
        m.position.copy(pos); 
        
        m.userData = {
            vel: new THREE.Vector3(
                (Math.random()-.5)*3,
                (Math.random()-.5)*3,
                (Math.random()-.5)*3
            )
        }; 
        scene.add(m); 
        particles.push(m); 
    } 
}
        
        function checkCollision(plane, obj) {
            const dx = Math.abs(plane.position.x - obj.position.x); const dy = Math.abs(plane.position.y - obj.position.y); const dz = Math.abs(plane.position.z - obj.position.z);
            let hitX = 5, hitY = 2.5, hitZ = 3;
            if(['fuel', 'wrench', 'rocket', 'missile', 'drill', 'cloud'].includes(obj.userData.type)) { hitX = 8; hitY = 5; hitZ = 5; }
            if(obj.userData.type === 'balloon') { hitX = 4; hitY = 6; hitZ = 4; }
            if(obj.userData.type === 'bridge') { hitX = 35; hitY = 2; hitZ = 2; }
            if(obj.userData.type === 'alien_laser') { if(dx < 9 && dz < 7.5) return true; return false; }
            return (dx < hitX && dy < hitY && dz < hitZ);
        }

        function startGame(mode) { 
            controlMode = mode; AudioSys.startGameMusic(); isPlaying=true; document.getElementById('start-screen').classList.add('hidden');
            if (controlMode === 'touch') { document.getElementById('mobile-controls').classList.remove('hidden'); } 
            else { document.getElementById('mobile-controls').classList.add('hidden'); if(controlMode === 'mouse') { document.body.requestPointerLock(); } }
            clock.start(); resetLogic(); 
        }

        function togglePause(){
            isPaused=!isPaused; const pScreen = document.getElementById('pause-screen'); pScreen.classList.toggle('hidden'); 
            if(isPaused) { switchScreen('pause-screen'); document.getElementById('mobile-controls').classList.add('hidden'); if(AudioSys.engineGain) AudioSys.engineGain.gain.value = 0; AudioSys.pauseMusic(true); clock.stop(); if(document.pointerLockElement) document.exitPointerLock(); } 
            else { pScreen.classList.add('hidden'); if(controlMode === 'touch') document.getElementById('mobile-controls').classList.remove('hidden'); if(controlMode === 'mouse') document.body.requestPointerLock(); AudioSys.pauseMusic(false); clock.start(); }
        }
        function quitToMenu() { isPaused = false; isPlaying = false; document.getElementById('pause-screen').classList.add('hidden'); document.getElementById('mobile-controls').classList.add('hidden'); AudioSys.startMenuMusic(); resetGame(); if(AudioSys.engineGain) AudioSys.engineGain.gain.value = 0; if(document.pointerLockElement) document.exitPointerLock(); }
        function resetGame(){ document.getElementById('game-over-screen').classList.add('hidden'); document.getElementById('mobile-controls').classList.add('hidden'); switchScreen('start-screen'); AudioSys.startMenuMusic(); }
        
        function resetLogic(){
            playerLogicalX = 0;
            enemiesKilled = 0; 
    itemsCollected = 0;
    const turboBox = document.getElementById('turbo-toggle');
    isTurboMode = (turboBox && turboBox.checked);
            score=0; distance=0; health=100; energy=100; invincibleTimer=0; birdShieldTimer=0; drillTimer=0;
            comboCount = 0; comboTimer = 0; currentComboMultiplier = 1.0; overdriveLevel = 0;
            document.getElementById('combo-wrapper').style.opacity = 0; document.getElementById('combo-container').classList.remove('combo-overdrive'); document.getElementById('overdrive-overlay').style.opacity = 0; document.getElementById('overdrive-overlay').classList.remove('pulsing-gold'); document.getElementById('combo-label-text').innerText = "COMBO !";
            isIntro = true; introStartTime = Date.now(); gameSpeed = 0; screenShake = 0; bounceForce = 0; wallHitTimer = 0; isInputLocked = false;
            mouseX=0; mouseY=0; joystickInput = {x:0, y:0}; keyInput = {x:0, y:0}; isBoosting = false;
            objects.forEach(o=>scene.remove(o));objects=[]; particles.forEach(p=>scene.remove(p));particles=[];
            plane.position.set(0,0,0); plane.rotation.set(0,0,0); propeller.visible = true; drillMesh.visible = false; 
            terrainChunks.forEach(c=>scene.remove(c));terrainChunks=[]; for(let i=0;i<CONFIG.chunkCount;i++)terrainChunks.push(createChunk(-i*CONFIG.chunkSize));
            document.getElementById('shield-overlay').style.opacity = 0; document.getElementById('speed-overlay').style.opacity = 0;
            updateHUD();
        }

        function activateInvincibleBoost() { invincibleTimer = INVINCIBLE_DURATION; AudioSys.boost(); document.getElementById('speed-overlay').style.opacity = 1; }
        function activateBirdShield() { birdShieldTimer = BIRD_SHIELD_DURATION; AudioSys.boost(); document.getElementById('shield-overlay').style.opacity = 1; }
        function activateDrill() { drillTimer = DRILL_DURATION; AudioSys.drill(); propeller.visible = false; drillMesh.visible = true; }

        function updateOverdrive() {
            let newLevel = 0;
            if(comboCount >= 20) newLevel = 5; else if(comboCount >= 15) newLevel = 4; else if(comboCount >= 10) newLevel = 3; else if(comboCount >= 6) newLevel = 2; else if(comboCount >= 3) newLevel = 1;
            if(newLevel > overdriveLevel) {
                overdriveLevel = newLevel;
                const colors = ['#FFF', '#FFD700', '#FF8800', '#FF0000', '#FF00FF', '#00FFFF']; const texts = ['COMBO', 'OVERDRIVE I', 'OVERDRIVE II', 'OVERDRIVE III', 'OVERDRIVE IV', 'MAXIMUM'];
                const cContainer = document.getElementById('combo-container'); const cLabel = document.getElementById('combo-label-text'); const cCount = document.getElementById('combo-count-val'); const cMult = document.getElementById('combo-mult-val');
                cLabel.innerText = texts[overdriveLevel]; const col = colors[overdriveLevel]; cLabel.style.color = col; cCount.style.color = col; cMult.style.color = col;
                cContainer.classList.remove('shake-anim'); void cContainer.offsetWidth; cContainer.classList.add('shake-anim');
                if(overdriveLevel >= 1) { const ov = document.getElementById('overdrive-overlay'); ov.style.opacity = 0.3 + (overdriveLevel * 0.1); ov.style.boxShadow = `inset 0 0 50px ${col}`; }
            }
        }

        function triggerCombo() {
            comboCount++; comboTimer = COMBO_WINDOW; currentComboMultiplier = Math.min(5.0, 1 + (comboCount * 0.5));
            if (overdriveLevel >= 1 || comboCount >= 3) { energy = Math.min(100, energy + 95); AudioSys.fuel(); }
            updateOverdrive();
            document.getElementById('combo-wrapper').style.opacity = 1; document.getElementById('combo-count-val').innerText = "x" + comboCount; document.getElementById('combo-mult-val').innerText = "SCORE x" + currentComboMultiplier.toFixed(1);
        }

        function takeDamage(amount) {
             if (invincibleTimer > 0 || isIntro || !isPlaying) return; 
             health -= amount; AudioSys.hit(); spawnParticles(plane.position, 0xFF0000); screenShake = 1.5; 
             const ov = document.getElementById('damage-overlay'); ov.style.opacity=1; setTimeout(()=>ov.style.opacity=0,200); 
             if(health<=0){ 
                 health = 0; isPlaying=false; AudioSys.gameOver(); 
                 finalizeQuests({ dist: distance, score: score, kill: enemiesKilled, collect: itemsCollected });
                 document.getElementById('final-score').innerText=`${score} PTS`; document.getElementById('final-dist').innerText=`${Math.floor(distance)}M`; 
                 document.getElementById('mobile-controls').classList.add('hidden'); switchScreen('game-over-screen'); if(document.pointerLockElement) document.exitPointerLock();
                 if(isHighScore(score)) { document.getElementById('highscore-form').classList.remove('hidden'); document.getElementById('player-name-input').value = ""; setTimeout(()=>document.getElementById('player-name-input').focus(), 100); } 
                 else { document.getElementById('highscore-form').classList.add('hidden'); }
            } updateHUD();
        }
        
        function healFull() { health = 100; AudioSys.heal(); const ov = document.getElementById('heal-overlay'); ov.style.opacity=1; setTimeout(()=>ov.style.opacity=0,300); updateHUD(); }
        function refillEnergy() { energy = Math.min(100, energy + 50); AudioSys.fuel(); updateHUD(); }

        function updateHUD() { 
            document.getElementById('score-display').innerText=score; document.getElementById('dist-display').innerText=Math.floor(distance) + " m";
            document.getElementById('health-fill').style.width = health + "%"; document.getElementById('energy-fill').style.width = energy + "%";
            if(comboTimer > 0) { const pct = (comboTimer / COMBO_WINDOW); document.getElementById('combo-timer-fill').style.transform = `scaleX(${pct})`; }
            const elRocket = document.getElementById('effect-rocket'); if(invincibleTimer > 0) { elRocket.classList.remove('hidden'); document.getElementById('fill-rocket').style.transform = `scaleX(${invincibleTimer / INVINCIBLE_DURATION})`; } else { elRocket.classList.add('hidden'); document.getElementById('speed-overlay').style.opacity = 0; }
            const elShield = document.getElementById('effect-shield'); if(birdShieldTimer > 0) { elShield.classList.remove('hidden'); document.getElementById('fill-shield').style.transform = `scaleX(${birdShieldTimer / BIRD_SHIELD_DURATION})`; } else { elShield.classList.add('hidden'); document.getElementById('shield-overlay').style.opacity = 0; }
            const elDrill = document.getElementById('effect-drill'); if(drillTimer > 0) { elDrill.classList.remove('hidden'); document.getElementById('fill-drill').style.transform = `scaleX(${drillTimer / DRILL_DURATION})`; } else { elDrill.classList.add('hidden'); }
        }

        function animate() {
            requestAnimationFrame(animate); if(isPaused)return;
            
            if(!isPlaying){ plane.rotation.z=Math.sin(Date.now()*0.001)*0.05; propeller.rotation.z+=0.2; renderer.render(scene, camera); return; }

            const dt = Math.min(clock.getDelta(), 0.1); const fpsFactor = dt * 60; 
            
            frameCount++; distance += gameSpeed * 0.1 * fpsFactor;
            if(wallHitTimer > 0) wallHitTimer -= fpsFactor;
            
            sunMesh.position.z = plane.position.z - 450; 
            sunMesh.position.x = plane.position.x * 0.3; 
            sunMesh.position.y = 60;

            const sunLightObj = scene.children.find(c => c.isDirectionalLight);
            if(sunLightObj) {
                sunLightObj.position.z = plane.position.z - 100; 
                sunLightObj.position.x = plane.position.x - 30; 
                sunLightObj.position.y = 60; 
                sunLightObj.target.position.set(plane.position.x, plane.position.y, plane.position.z);
                sunLightObj.target.updateMatrixWorld();
            }

            starField.position.x = plane.position.x; starField.position.z = plane.position.z;
            const positions = starField.geometry.attributes.position.array;
            for(let i=2; i<positions.length; i+=3) { positions[i] += gameSpeed * 0.05 * fpsFactor; if(positions[i] > 200) positions[i] -= 800; }
            starField.geometry.attributes.position.needsUpdate = true;

            if(scene.fog) {
                const colors = getCurrentBiomeColors(plane.position.z);
                scene.fog.color.setHex(colors.fog);
            }

            let distMult = 1 + (distance / 10000); distMult = Math.min(4, distMult);
            const speedRatio = (gameSpeed - CONFIG.baseSpeed) / (CONFIG.maxBoostSpeed - CONFIG.baseSpeed);
            let engineVolMult = 1.0;
            if(isIntro) { const elapsed = Date.now() - introStartTime; engineVolMult = Math.min(1, elapsed / INTRO_DURATION_MS); }
            AudioSys.updateEngine(Math.max(0, speedRatio), engineVolMult);

            const sens = 0.02 * fpsFactor * inputSensitivity;
            if (controlMode === 'touch') { mouseX += joystickInput.x * sens; mouseY += joystickInput.y * sens; } 
            else if (controlMode === 'keyboard') {
                const kSpeedX = 0.03 * fpsFactor * inputSensitivity; const kSpeedY = 0.03 * fpsFactor * inputSensitivity;
                if(keyInput.x !== 0) mouseX += keyInput.x * kSpeedX; if(keyInput.y !== 0) mouseY += keyInput.y * kSpeedY;
            }
            mouseX = Math.max(-1, Math.min(1, mouseX)); mouseY = Math.max(-1, Math.min(1, mouseY));

            if(comboTimer > 0) {
                comboTimer -= fpsFactor; const pct = comboTimer / COMBO_WINDOW; document.getElementById('combo-timer-fill').style.transform = `scaleX(${pct})`;
                if(comboTimer <= 0) {
                    comboCount = 0; currentComboMultiplier = 1.0; overdriveLevel = 0;
                    document.getElementById('combo-wrapper').style.opacity = 0; document.getElementById('combo-container').classList.remove('combo-overdrive'); document.getElementById('combo-label-text').innerText = "COMBO !"; document.getElementById('overdrive-overlay').style.opacity = 0;
                    const els = ['combo-label-text', 'combo-count-val', 'combo-mult-val']; els.forEach(id => document.getElementById(id).style.color = "");
                }
            }
            if (birdShieldTimer > 0) birdShieldTimer -= fpsFactor;
            if (drillTimer > 0) { drillTimer -= fpsFactor; drillMesh.rotation.z += 0.6 * fpsFactor; if(drillTimer <= 0) { drillMesh.visible = false; propeller.visible = true; } }
            if (invincibleTimer > 0) invincibleTimer -= fpsFactor;
            
            if (!isIntro) { 
                let speedConfig = isTurboMode ? CONFIG.baseSpeed * 2 : CONFIG.baseSpeed;
                let base = speedConfig * distMult; 
                let mult = 1.0 + (overdriveLevel * 0.2); 
                let boostAdd = 0;
                if (isBoosting && energy > 0) { boostAdd += 2.0; energy -= 0.25 * fpsFactor; }
                if (invincibleTimer > 0) { boostAdd += 3.0; } 
                gameSpeed = (base * mult) + boostAdd;
            }
            updateHUD(); 
            updateLiveQuests({ dist: distance, score: score, combo: comboCount });

            if(gameSpeed > 3 && frameCount % Math.floor(3/fpsFactor) === 0) { const color = invincibleTimer > 0 ? 0xFF00FF : 0x00FFFF; spawnParticles(plane.position, color, 1); }
            
            let targetPlayerOffset = 0; 
            let targetY = 0;

            if (isIntro) {
                const elapsed = Date.now() - introStartTime; const progress = Math.min(1, elapsed / INTRO_DURATION_MS);
                gameSpeed = CONFIG.baseSpeed * progress;
                const terrainH = getTerrainHeight(0, plane.position.z); 
                targetPlayerOffset = 0; 
                targetY = (terrainH + 2) + ((0 - (terrainH + 2)) * progress); 
                mouseX = 0; mouseY = 0; 
                if(elapsed >= INTRO_DURATION_MS) isIntro = false;
            }
            else if (isInputLocked) { 
                targetPlayerOffset = 0; targetY = 0; 
            } 
            else { 
                let xRange = (window.innerWidth > window.innerHeight) ? 65 : 45; 
                targetPlayerOffset = mouseX * xRange; 
                targetY = mouseY * 15; 
            }
            
            bounceForce *= 0.9; 
            const smoothFactor = (isIntro ? 0.05 : 0.1) * fpsFactor; 
            
            let prevLogicalX = playerLogicalX;
            playerLogicalX += (targetPlayerOffset - playerLogicalX) * smoothFactor + bounceForce;
            let moveDelta = playerLogicalX - prevLogicalX;

            plane.position.z -= gameSpeed * fpsFactor;
            const currentCurveX = getTrackOffset(plane.position.z);
            
            plane.position.x = playerLogicalX + currentCurveX;
            plane.position.y += (targetY - plane.position.y) * smoothFactor; 

            const terrainHeight = getTerrainHeight(playerLogicalX, plane.position.z);
            
            if (!isIntro && plane.position.y < terrainHeight + 1.0) { 
                if (invincibleTimer > 0) { 
                    plane.position.y = terrainHeight + 2; 
                    spawnParticles(plane.position, 0xffaa00, 3); 
                } else { 
                    takeDamage(20); 
                    plane.position.y = terrainHeight + 3; 
                } 
            }
            
            if (!isIntro && Math.abs(playerLogicalX) > 32) { 
                if(invincibleTimer <= 0 && wallHitTimer <= 0) { 
                    takeDamage(25); wallHitTimer = 30; 
                    bounceForce = (playerLogicalX > 0) ? -12.0 : 12.0; 
                    mouseX = 0; 
                    spawnParticles(plane.position, 0x8B4513, 10); 
                } else if(invincibleTimer > 0) {
                    bounceForce = (playerLogicalX > 0) ? -1.0 : 1.0; 
                }
            }

            let targetRotZ = 0;
            if (controlMode === 'touch') {
                targetRotZ = -joystickInput.x * 0.8;
            } else {
                targetRotZ = -moveDelta * 0.5;
            }
            targetRotZ -= (bounceForce * 0.5);
            targetRotZ = Math.max(-0.8, Math.min(0.8, targetRotZ));
            plane.rotation.z += (targetRotZ - plane.rotation.z) * 0.15 * fpsFactor;

            if (isIntro) plane.rotation.x = -0.2; 
            else {
                let targetRotX = (targetY - plane.position.y) * 0.03;
                plane.rotation.x += (targetRotX - plane.rotation.x) * 0.1 * fpsFactor;
            }
            
            if (isIntro) plane.rotation.x = -0.2; 
            else plane.rotation.x = (targetY - plane.position.y) * 0.03; 
            
            const tangentFront = getTrackOffset(plane.position.z - 20);
            const tangentBack = getTrackOffset(plane.position.z + 20);
            const curveAngle = Math.atan2(tangentFront - tangentBack, -40);
            
            plane.rotation.y = Math.PI + curveAngle - (moveDelta * 0.2);

            propeller.rotation.z += (gameSpeed * 0.5 * fpsFactor);

            let baseFov = 60 + (overdriveLevel * 5); if(isBoosting) baseFov += 10;
            camera.fov += (baseFov - camera.fov) * 0.05 * fpsFactor; 
            camera.updateProjectionMatrix();
            
            screenShake *= 0.9; if(screenShake < 0.01) screenShake = 0;
            
            camera.position.x += (plane.position.x - camera.position.x) * 0.1 * fpsFactor + (Math.random()-0.5) * screenShake; 
            camera.position.y = 10 + (plane.position.y * 0.3) + (Math.random()-0.5) * screenShake; 
            camera.position.z = plane.position.z + 28; 
            
            const lookDist = 50;
            const futureTrackX = getTrackOffset(plane.position.z - lookDist);
            camera.lookAt(futureTrackX + playerLogicalX, plane.position.y, plane.position.z - lookDist);
            
            let spawnRate = Math.max(5, 20 - (distance / 1000));
            if(Math.floor(frameCount) % Math.floor(spawnRate/fpsFactor) === 0) spawnObject();

            for(let i=objects.length-1; i>=0; i--) {
                let o = objects[i]; 
                
                const objCurveX = getTrackOffset(o.position.z);

                if(o.userData.type === 'bird') { 
                    if (o.userData.dead) { o.position.y -= 1.0 * fpsFactor; o.rotation.x += 0.2 * fpsFactor; } 
                    else { 
                        o.userData.wings[0].rotation.z = Math.sin(frameCount * 0.5); 
                        o.userData.wings[1].rotation.z = -Math.sin(frameCount * 0.5); 
                        o.position.z += 0.4 * fpsFactor; 
                        o.position.y += Math.sin(frameCount * 0.1) * 0.02 * fpsFactor; 
                        if(o.userData.isMoving) { 
                            o.userData.relativeX = o.userData.baseRelativeX + Math.sin(frameCount * 0.05 + o.userData.phase) * 7; 
                        }
                    } 
                }
                else if(['fuel', 'wrench', 'rocket', 'missile', 'drill'].includes(o.userData.type)) { o.rotation.y += 0.05 * fpsFactor; let pulse = Math.sin(frameCount * 0.15) * 0.25; let s = o.userData.baseScale + pulse; o.scale.set(s, s, s); }
                else if(o.userData.type === 'balloon') { o.position.y += Math.sin(frameCount * 0.05) * 0.1 * fpsFactor; let pulse = Math.sin(frameCount * 0.05) * 0.15; let s = o.userData.baseScale + pulse; o.scale.set(s, s, s); }
                else if(o.userData.type === 'cloud') { o.lookAt(camera.position); }

                if (o.userData.relativeX !== undefined) {
                    o.position.x = o.userData.relativeX + objCurveX;
                }

                if(!o.userData.dead && checkCollision(plane, o)) { 
                    itemsCollected++;
                    const timeMultiplier = 1 + (distance / 5000); 
                    
                    if(o.userData.type==='bird'){ 
                        if (invincibleTimer > 0 || (isBoosting && energy > 0)) { let pts = Math.floor(500 * currentComboMultiplier * timeMultiplier); score += pts; enemiesKilled++; triggerCombo(); AudioSys.smash(); spawnParticles(o.position, 0xff3333, 10); o.userData.dead = true; spawnFloatingText("+" + pts, o.position, "#FFD700"); } 
                        else if (birdShieldTimer > 0) { let pts = Math.floor(200 * currentComboMultiplier * timeMultiplier); score += pts; triggerCombo(); AudioSys.hit(); o.userData.dead = true; spawnFloatingText("+" + pts, o.position, "#FFD700"); } 
                        else { takeDamage(25); } 
                    }
                    else if(o.userData.type === 'balloon') { 
                        if (invincibleTimer > 0 || (isBoosting && energy > 0)) { let pts = Math.floor(1000 * currentComboMultiplier * timeMultiplier); score += pts; enemiesKilled++; triggerCombo(); AudioSys.smash(); spawnParticles(o.position, 0xFFFFFF, 20); scene.remove(o); objects.splice(i,1); spawnFloatingText("+" + pts, o.position, "#FFD700"); } 
                        else if (drillTimer > 0) { let pts = Math.floor(1000 * currentComboMultiplier * timeMultiplier); score += pts; triggerCombo(); AudioSys.smash(); spawnParticles(o.position, 0xFFFFFF, 20); scene.remove(o); objects.splice(i,1); spawnFloatingText("+" + pts, o.position, "#FFD700"); } 
                        else { takeDamage(50); } 
                    }
                    else if(o.userData.type === 'alien_laser') { if (invincibleTimer > 0) {} else { takeDamage(50); plane.position.z += 2; } }
                    else if(o.userData.type === 'bridge') { if (invincibleTimer > 0) { score+=500; spawnParticles(o.position, 0x8B4513, 20); scene.remove(o); objects.splice(i,1); spawnFloatingText("+500", o.position, "#FFD700"); } else { takeDamage(50); plane.position.z += 2; } }
                    else if(o.userData.type==='rocket') { itemsCollected++; activateInvincibleBoost(); score+=500; spawnParticles(o.position, CONFIG.colors.rocket, 10); scene.remove(o); objects.splice(i,1); spawnFloatingText("HYPER!", o.position, "#FF00FF"); }
                    else if(o.userData.type==='drill') { itemsCollected++; activateDrill(); score+=500; spawnParticles(o.position, CONFIG.colors.drill, 10); scene.remove(o); objects.splice(i,1); spawnFloatingText("VRILLE!", o.position, "#FFFF00"); }
                    else if(o.userData.type==='wrench') { itemsCollected++; healFull(); spawnParticles(o.position, CONFIG.colors.wrench, 10); scene.remove(o); objects.splice(i,1); spawnFloatingText("REPARE", o.position, "#00FF00"); }
                    else if(o.userData.type==='fuel') { itemsCollected++; refillEnergy(); spawnParticles(o.position, CONFIG.colors.fuel, 10); scene.remove(o); objects.splice(i,1); spawnFloatingText("FUEL", o.position, "#FF0000"); }
                    else if(o.userData.type==='missile') { itemsCollected++; activateBirdShield(); spawnParticles(o.position, CONFIG.colors.missile, 10); scene.remove(o); objects.splice(i,1); spawnFloatingText("BOUCLIER", o.position, "#00FFFF"); }
                    else { itemsCollected++; let pts = Math.floor(100 * currentComboMultiplier * timeMultiplier); score+=pts; AudioSys.coin(); spawnParticles(o.position, CONFIG.colors.cloud, 5); scene.remove(o); objects.splice(i,1); spawnFloatingText("+" + pts, o.position, "#FFD700"); } 
                } 
                else if(o.position.z > camera.position.z + 50){ 
                    scene.remove(o); objects.splice(i,1);
                }
            }

            if(terrainChunks.length > 0 && terrainChunks[0].position.z > camera.position.z + 300) { 
                scene.remove(terrainChunks[0]); 
                terrainChunks.shift(); 
                let lastChunkZ = terrainChunks[terrainChunks.length-1].position.z;
                terrainChunks.push(createChunk(lastChunkZ - CONFIG.chunkSize)); 
            }
            renderer.render(scene, camera);
        }

        let garageScene, garageCamera, garageRenderer, garagePlane;
        let isGarageOpen = false;
        let garageRotationSpeed = 0.01;
        let isDraggingPlane = false;
        let lastMouseX = 0;

        function initGarage3D() {
            if(garageRenderer) return; 

            const container = document.getElementById('garage-3d-container');
            const w = container.clientWidth;
            const h = container.clientHeight;

            garageScene = new THREE.Scene();
            
            garageCamera = new THREE.PerspectiveCamera(50, w/h, 0.1, 100);
            garageCamera.position.set(0, 4, 14);
            garageCamera.lookAt(0, 0, 0);

            garageRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            garageRenderer.setSize(w, h);
            container.appendChild(garageRenderer.domElement);

            const ambient = new THREE.AmbientLight(0xFFFFFF, 0.6);
            garageScene.add(ambient);
            const dirLight = new THREE.DirectionalLight(0xFFFFFF, 1.0);
            dirLight.position.set(5, 10, 7);
            garageScene.add(dirLight);
            const backLight = new THREE.DirectionalLight(0x4444FF, 0.5);
            backLight.position.set(-5, 0, -10);
            garageScene.add(backLight);

            container.addEventListener('mousedown', e => { isDraggingPlane = true; lastMouseX = e.clientX; garageRotationSpeed = 0; });
            window.addEventListener('mousemove', e => {
                if(isDraggingPlane && garagePlane) {
                    const delta = e.clientX - lastMouseX;
                    garagePlane.rotation.y += delta * 0.01;
                    lastMouseX = e.clientX;
                }
            });
            window.addEventListener('mouseup', () => { isDraggingPlane = false; garageRotationSpeed = 0.005; });

            container.addEventListener('touchstart', e => { isDraggingPlane = true; lastMouseX = e.touches[0].clientX; garageRotationSpeed = 0; }, {passive:false});
            container.addEventListener('touchmove', e => {
                if(isDraggingPlane && garagePlane) {
                    e.preventDefault();
                    const delta = e.touches[0].clientX - lastMouseX;
                    garagePlane.rotation.y += delta * 0.01;
                    lastMouseX = e.touches[0].clientX;
                }
            }, {passive:false});
            container.addEventListener('touchend', () => { isDraggingPlane = false; garageRotationSpeed = 0.005; });
        }

        function updateGaragePlane() {
            if(!garageScene) return;
            if(garagePlane) garageScene.remove(garagePlane);
            
            garagePlane = buildPlaneModel(previewSkinIndex);
            garagePlane.rotation.y = -Math.PI / 4; 
            garagePlane.rotation.x = 0.2; 
            garageScene.add(garagePlane);
        }

        function animateGarage() {
            if(!isGarageOpen) return;
            requestAnimationFrame(animateGarage);
            
            if(garagePlane) {
                if(!isDraggingPlane) garagePlane.rotation.y += garageRotationSpeed;
                if(garagePlane.userData.propeller) garagePlane.userData.propeller.rotation.z += 0.2;
                garagePlane.position.y = Math.sin(Date.now() * 0.002) * 0.5;
            }
            
            garageRenderer.render(garageScene, garageCamera);
        }

        init();
    </script>
</body>
</html>
