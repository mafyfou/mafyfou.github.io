<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <!-- Viewport optimis√© pour iPhone (pas de zoom, plein √©cran) -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Plane Rush iOS</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'VT323', monospace; user-select: none; -webkit-user-select: none; touch-action: none; }
        
        /* FOND */
        #background-gradient { position: absolute; width: 100%; height: 100%; z-index: -2; background: linear-gradient(to bottom, #2e004f 0%, #8b005e 40%, #ff5500 70%, #ffd700 90%, #ffffcc 100%); }
        
        /* UI */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; padding: 20px; box-sizing: border-box; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; }
        
        /* HUD adapt√© mobile (plus gros, plus √©cart√© pour le notch/dynamic island) */
        .hud-top { display: flex; justify-content: space-between; width: 100%; align-items: flex-start; padding: 0 20px; }
        .stats-group { display: flex; flex-direction: column; gap: 5px; }
        .hud-box { background: rgba(80, 40, 10, 0.8); padding: 5px 10px; border: 2px solid #FFD700; box-shadow: 2px 2px 0px #8B4513; color: #FFF; font-size: 24px; display: flex; flex-direction: column; width: fit-content; }
        .hud-label { font-size: 14px; color: #FFA500; text-transform: uppercase; }

        .status-bars { display: flex; flex-direction: column; gap: 8px; align-items: flex-end; }
        .bar-container { width: 150px; height: 15px; background: #3e2723; border: 2px solid #FFD700; position: relative; }
        .bar-fill { width: 100%; height: 100%; transition: width 0.1s linear; }
        .bar-icon { position: absolute; top: -5px; left: -25px; font-size: 20px; }
        #health-fill { background: #4caf50; }
        #energy-fill { background: #2196f3; } 

        #boost-container { width: 300px; height: 15px; background: rgba(0,0,0,0.5); border: 2px solid #FF00FF; margin: 0 auto; overflow: hidden; opacity: 0; transition: opacity 0.3s; }
        #boost-fill { width: 100%; height: 100%; background: repeating-linear-gradient(45deg, #FF00FF, #FF00FF 10px, #FFFFFF 10px, #FFFFFF 20px); transform-origin: left; transform: scaleX(0); transition: transform 0.1s linear; }
        #notif-label { text-align: center; color: #FF00FF; font-size: 30px; text-shadow: 2px 2px 0 #000; margin-bottom: 5px; opacity: 0; transition: opacity 0.3s; }

        /* CONTROLES MOBILES */
        #mobile-controls {
            position: absolute; bottom: 30px; left: 0; width: 100%; height: 150px;
            pointer-events: none; /* Laisse passer les clics si pas sur un bouton */
            display: flex; justify-content: space-between; padding: 0 40px; box-sizing: border-box;
            z-index: 20;
        }

        /* JOYSTICK */
        #joystick-zone {
            width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: relative;
            pointer-events: auto; /* Active le touch */
            touch-action: none;
        }
        #joystick-knob {
            width: 50px; height: 50px;
            background: rgba(255, 215, 0, 0.8);
            border-radius: 50%;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px #FFD700;
        }

        /* BOUTON BOOST */
        #boost-btn {
            width: 100px; height: 100px;
            background: rgba(0, 255, 255, 0.2);
            border: 4px solid #00FFFF;
            border-radius: 50%;
            pointer-events: auto;
            display: flex; justify-content: center; align-items: center;
            color: #00FFFF; font-size: 20px; text-shadow: 0 0 5px #FFF;
            box-shadow: 0 0 15px #00FFFF;
            transition: transform 0.1s, background 0.1s;
        }
        #boost-btn:active { transform: scale(0.9); background: rgba(0, 255, 255, 0.5); }

        /* MENUS */
        .overlay-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(80, 30, 0, 0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; transition: opacity 0.3s; }
        .btn { background: #FFA500; color: #3e2723; border: 4px solid #3e2723; padding: 15px 40px; font-size: 30px; font-family: 'VT323', monospace; margin-top: 20px; cursor: pointer; box-shadow: 6px 6px 0 #3e2723; transition: transform 0.1s; }
        .btn:active { transform: scale(0.95); }
        
        #damage-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 40%, rgba(255,0,0,0.6) 100%); opacity: 0; pointer-events: none; transition: opacity 0.1s; z-index: 50; }
        #speed-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 50%, rgba(255, 0, 255, 0.2) 80%, rgba(255, 255, 255, 0.4) 100%); opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 40; mix-blend-mode: hard-light; }
        #shield-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 50%, rgba(0, 255, 0, 0.2) 100%); opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 40; mix-blend-mode: screen; }
        .hidden { display: none !important; }
        
        h1 { font-size: 60px; color: #FFD700; text-shadow: 4px 4px 0 #8B4513; margin: 0; text-align: center; }
        h1 span { display: block; font-size: 30px; color: #FFA500; transform: rotate(-2deg); }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
</head>
<body>
    <div id="background-gradient"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="stats-group">
                <div class="hud-box"><span class="hud-label">Score</span><span id="score-display">0</span></div>
                <div class="hud-box"><span class="hud-label">Dist</span><span id="dist-display">0m</span></div>
            </div>
            <div style="flex-grow:1; display:flex; flex-direction:column; align-items:center; justify-content: flex-start; padding-top: 10px;">
                 <div id="notif-label">INVINCIBLE !</div>
                 <div id="boost-container"><div id="boost-fill"></div></div>
            </div>
            <div class="status-bars">
                <div class="bar-container"><div class="bar-icon">üîß</div><div class="bar-fill" id="health-fill"></div></div>
                <div class="bar-container"><div class="bar-icon">‚õΩ</div><div class="bar-fill" id="energy-fill"></div></div>
            </div>
        </div>

        <!-- CONTROLES TACTILES -->
        <div id="mobile-controls">
            <div id="joystick-zone">
                <div id="joystick-knob"></div>
            </div>
            <div id="boost-btn" ontouchstart="startManualBoost()" ontouchend="stopManualBoost()">
                BOOST
            </div>
        </div>
    </div>

    <div id="damage-overlay"></div><div id="speed-overlay"></div><div id="shield-overlay"></div>

    <div id="start-screen" class="overlay-screen">
        <h1>PLANE RUSH<span>iOS Edition</span></h1>
        <p style="color:#FFF; font-size: 18px; text-align:center;">Mode Paysage Recommand√©<br>Audio requis</p>
        <button class="btn" onclick="startGame()">TAP TO START</button>
    </div>
    
    <div id="game-over-screen" class="overlay-screen hidden">
        <h1 style="color:#ff3333">CRASH!</h1>
        <div style="text-align:center; color:white; font-size:30px; margin:20px;">
            <div id="final-score">Score: 0</div>
            <div id="final-dist" style="font-size:20px; color:#ccc">Dist: 0m</div>
        </div>
        <button class="btn" onclick="resetGame()">RETRY</button>
    </div>

    <script>
        // --- AUDIO ENGINE ---
        const AudioSys = { 
            ctx: null, engineOsc: null, engineGain: null, bgMusic: null,
            init: function() { 
                if(!this.ctx) { 
                    this.ctx = new (window.AudioContext||window.webkitAudioContext)(); 
                    this.engineOsc = this.ctx.createOscillator(); 
                    this.engineGain = this.ctx.createGain(); 
                    this.engineOsc.type = 'sawtooth'; 
                    this.engineOsc.frequency.value = 60; 
                    this.engineGain.gain.value = 0; 
                    this.engineOsc.connect(this.engineGain); 
                    this.engineGain.connect(this.ctx.destination); 
                    this.engineOsc.start(); 
                    // Essayer de charger la musique si pr√©sente
                    this.bgMusic = new Audio('music.mp3');
                    this.bgMusic.loop = true;
                    this.bgMusic.volume = 0.4;
                } 
                if(this.ctx.state === 'suspended') this.ctx.resume();
            },
            updateEngine: function(ratio) { 
                if(!this.engineOsc) return; 
                this.engineOsc.frequency.setTargetAtTime(60 + (ratio * 100), this.ctx.currentTime, 0.1); 
                this.engineGain.gain.setTargetAtTime(0.05 + (ratio * 0.05), this.ctx.currentTime, 0.1); 
            },
            play: function(f,t,d,v=0.1) { 
                if(!this.ctx)return; const o=this.ctx.createOscillator(),g=this.ctx.createGain(); 
                o.type=t; o.frequency.value=f; g.gain.setValueAtTime(v,this.ctx.currentTime); 
                g.gain.exponentialRampToValueAtTime(0.01,this.ctx.currentTime+d); 
                o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(this.ctx.currentTime+d); 
            }, 
            coin:()=>AudioSys.play(600,'square',0.1), hit:()=>AudioSys.play(100,'sawtooth',0.3, 0.3), boost:()=>AudioSys.play(300,'square',0.5,0.1), smash:()=>AudioSys.play(50,'square',0.2,0.5), heal:()=>AudioSys.play(600,'sine',0.5,0.2), fuel:()=>AudioSys.play(200,'sawtooth',0.3,0.1), 
            gameOver:()=>{ AudioSys.play(60,'sawtooth',1.0, 0.5); if(AudioSys.engineGain) AudioSys.engineGain.gain.setTargetAtTime(0, AudioSys.ctx.currentTime, 0.1); if(AudioSys.bgMusic) AudioSys.bgMusic.pause(); },
            startMusic: () => { if(AudioSys.bgMusic) AudioSys.bgMusic.play().catch(e=>console.log("No music file or blocked")); }
        };
        
        // --- CONFIG ---
        const CONFIG = { 
            baseSpeed: 1.8, maxBoostSpeed: 4.5, chunkSize: 100, chunkCount: 14,
            colors: {
                birdBody: 0x5D4037, birdWing: 0x111111,
                cloud: 0xFFFFFF, rocket: 0xFF00FF, wrench: 0xC0C0C0, fuel: 0xFF0000, missile: 0x00FF00,
                terrainBase: 0x8B4513, terrainVar1: 0xA0522D, terrainVar2: 0xCD853F, 
                planeMain: 0xD32F2F, planeSec: 0xFFFFFF   
            }
        };
        
        let scene, camera, renderer, plane, propeller, sunMesh;
        let terrainChunks = [], objects = [], particles = [];
        let score = 0, health = 100, energy = 50, gameSpeed = CONFIG.baseSpeed, distance = 0;
        let isPlaying = false, isPaused = false, frameCount = 0;
        
        // MOBILE CONTROLS
        let joystick = { x: 0, y: 0, active: false, startX: 0, startY: 0, curX: 0, curY: 0 };
        let isManualBoosting = false;
        
        let invincibleTimer = 0; const INVINCIBLE_DURATION = 200;
        let birdShieldTimer = 0; const BIRD_SHIELD_DURATION = 600; 
        let bounceForce = 0, wallHitTimer = 0, isInputLocked = false;
        const simplex = new SimplexNoise();

        function getDifficultyMultiplier() { return 1 + (distance / 2000); }

        function getTerrainHeight(x, z) {
            let noise = simplex.noise2D(x * 0.02, z * 0.02);
            let h = -12; 
            if(Math.abs(x) > 30) { let canyonH = Math.max(0, noise * 40 + (Math.abs(x) - 30) * 1.5); h += Math.floor(canyonH / 4) * 4; }
            let spikeNoise = simplex.noise2D(x * 0.08, z * 0.08); 
            if (spikeNoise > 0.82 && Math.abs(x) < 25) { let spikeH = (spikeNoise - 0.82) * 120; h += Math.floor(spikeH / 4) * 4; }
            return h;
        }

        function init() {
            scene = new THREE.Scene(); 
            scene.fog = new THREE.Fog(0xFFD700, 100, 400);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 24);

            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.BasicShadowMap; 
            document.body.appendChild(renderer.domElement);
            
            const sunLight = new THREE.DirectionalLight(0xffeba1, 1.2); sunLight.position.set(50, 80, 50); sunLight.castShadow = true; 
            sunLight.shadow.mapSize.width = 1024; sunLight.shadow.mapSize.height = 1024;
            sunLight.shadow.camera.left = -100; sunLight.shadow.camera.right = 100; scene.add(sunLight); 
            const ambient = new THREE.AmbientLight(0xffaf7b, 0.6); scene.add(ambient);

            const sunGeo = new THREE.CircleGeometry(60, 32); const sunMat = new THREE.MeshBasicMaterial({ color: 0xFFFF00 }); sunMesh = new THREE.Mesh(sunGeo, sunMat); scene.add(sunMesh);

            createVoxelPlane();
            for(let i=0; i<CONFIG.chunkCount; i++) terrainChunks.push(createChunk(-i * CONFIG.chunkSize));

            setupJoystick();
            window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
            animate();
        }

        // --- JOYSTICK LOGIC ---
        function setupJoystick() {
            const zone = document.getElementById('joystick-zone');
            const knob = document.getElementById('joystick-knob');
            
            zone.addEventListener('touchstart', e => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = zone.getBoundingClientRect();
                joystick.active = true;
                joystick.startX = rect.left + rect.width/2;
                joystick.startY = rect.top + rect.height/2;
                // Place le knob l√† o√π on touche initialement pour "attraper"
                updateJoystick(touch.clientX, touch.clientY);
            }, {passive: false});

            zone.addEventListener('touchmove', e => {
                e.preventDefault();
                if(joystick.active) updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
            }, {passive: false});

            const resetJoystick = (e) => {
                if(e) e.preventDefault();
                joystick.active = false;
                joystick.x = 0; joystick.y = 0;
                knob.style.transform = `translate(-50%, -50%)`; // Reset visual center
            };
            zone.addEventListener('touchend', resetJoystick);
            zone.addEventListener('touchcancel', resetJoystick);
        }

        function updateJoystick(clientX, clientY) {
            const zone = document.getElementById('joystick-zone');
            const knob = document.getElementById('joystick-knob');
            const maxDist = zone.offsetWidth / 2;

            let dx = clientX - joystick.startX;
            let dy = clientY - joystick.startY;
            const dist = Math.sqrt(dx*dx + dy*dy);

            // Clamp
            if(dist > maxDist) {
                const ratio = maxDist / dist;
                dx *= ratio; dy *= ratio;
            }

            // Move Knob visual
            knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

            // Normalize Output (-1 to 1)
            joystick.x = dx / maxDist;
            joystick.y = -(dy / maxDist); // Invert Y for game logic
        }

        function startManualBoost() { if(!isPaused && isPlaying && invincibleTimer <= 0) isManualBoosting = true; }
        function stopManualBoost() { isManualBoosting = false; }

        // --- ASSET CREATION ---
        function createVoxelBox(w, h, d, color, x, y, z, emissive=false) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshPhongMaterial({color: color, flatShading: true, emissive: emissive ? color : 0x000000, emissiveIntensity: emissive ? 0.5 : 0});
            const mesh = new THREE.Mesh(geo, mat); mesh.position.set(x, y, z); mesh.castShadow = true; mesh.receiveShadow = true;
            const edges = new THREE.EdgesGeometry(geo); const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 })); mesh.add(line);
            return mesh;
        }

        function createVoxelPlane() {
            plane = new THREE.Group();
            plane.add(createVoxelBox(2, 2, 6, 0xD32F2F, 0, 0, 0));
            plane.add(createVoxelBox(10, 0.5, 3, 0xFFFFFF, 0, 1.5, 0)); plane.add(createVoxelBox(8, 0.5, 3, 0xFFFFFF, 0, -1, 0));
            plane.add(createVoxelBox(4, 0.5, 2, 0xFFFFFF, 0, 0.5, 2.5)); plane.add(createVoxelBox(0.5, 2.5, 2.1, 0xD32F2F, 0, 1.1, 2.5)); 
            plane.add(createVoxelBox(0.2, 2.5, 0.5, 0x333333, -3, 0, 0)); plane.add(createVoxelBox(0.2, 2.5, 0.5, 0x333333, 3, 0, 0));
            propeller = createVoxelBox(6, 0.5, 0.5, 0x333333, 0, 0, -3.2); plane.add(propeller);
            scene.add(plane);
        }

        function createChunk(zPos) {
            const geo = new THREE.PlaneGeometry(200, CONFIG.chunkSize, 50, 25); geo.rotateX(-Math.PI/2);
            const pos = geo.attributes.position;
            const colors = [];
            for(let i=0; i<pos.count; i++) {
                let x = pos.getX(i); let zGlobal = zPos + pos.getZ(i); let rawH = getTerrainHeight(x, zGlobal);
                pos.setY(i, Math.floor(rawH / 2) * 2);
                let noiseCol = simplex.noise2D(x*0.05, zGlobal*0.05);
                let c = new THREE.Color(CONFIG.colors.terrainBase);
                if(noiseCol > 0.3) c.setHex(CONFIG.colors.terrainVar1); if(noiseCol < -0.3) c.setHex(CONFIG.colors.terrainVar2);
                colors.push(c.r, c.g, c.b);
            }
            geo.computeVertexNormals();
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const mat = new THREE.MeshPhongMaterial({vertexColors: true, flatShading:true, shininess:0});
            const m = new THREE.Mesh(geo, mat);
            m.position.z = zPos; m.receiveShadow = true; 
            const edges = new THREE.EdgesGeometry(geo, 15); const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 })); m.add(line);
            scene.add(m); return m;
        }

        function spawnObject() {
            const r = Math.random(); const diff = getDifficultyMultiplier();
            let birdProb = Math.min(0.6, 0.2 * diff); let wrenchProb = Math.max(0.01, 0.05 / diff); let fuelProb = Math.max(0.01, 0.05 / diff);
            let type;
            if (r < birdProb) type = 'bird'; else if (r < birdProb + wrenchProb) type = 'wrench'; else if (r < birdProb + wrenchProb + fuelProb) type = 'fuel'; else if (r < birdProb + wrenchProb + fuelProb + 0.03) type = 'rocket'; else if (r < birdProb + wrenchProb + fuelProb + 0.06) type = 'missile'; else type = 'cloud';

            let m;
            if(type==='bird') { 
                m = new THREE.Group();
                const body = createVoxelBox(1, 1, 1.5, CONFIG.colors.birdBody, 0, 0, 0); 
                const wingLGroup = new THREE.Group(); const wingL = createVoxelBox(2, 0.2, 1, CONFIG.colors.birdWing, -1.0, 0, 0); wingLGroup.add(wingL); wingLGroup.position.set(-0.5, 0.2, 0);
                const wingRGroup = new THREE.Group(); const wingR = createVoxelBox(2, 0.2, 1, CONFIG.colors.birdWing, 1.0, 0, 0); wingRGroup.add(wingR); wingRGroup.position.set(0.5, 0.2, 0);
                m.add(body, wingLGroup, wingRGroup); m.userData = {type:'bird', wings:[wingLGroup, wingRGroup], dead: false};
            } 
            else if(type==='fuel') { m = new THREE.Group(); m.add(createVoxelBox(1.5, 2, 1.5, CONFIG.colors.fuel, 0, 0, 0)); m.add(createVoxelBox(0.2, 0.5, 1, 0x333333, 0, 1.2, 0)); m.userData = {type:'fuel'}; }
            else if(type==='missile') { m = new THREE.Group(); m.add(createVoxelBox(1.5, 1.8, 0.2, 0xCCCCCC, 0, 0, 0)); m.add(createVoxelBox(1.0, 1.3, 0.3, CONFIG.colors.missile, 0, 0, 0, true)); m.userData = {type:'missile'}; }
            else if(type==='rocket') { m = new THREE.Group(); m.add(createVoxelBox(1, 1, 3, CONFIG.colors.rocket, 0, 0, 0, true)); m.add(createVoxelBox(1.2, 1.2, 0.5, 0xFFFFFF, 0, 0, -1.5)); m.userData = {type:'rocket'}; }
            else if(type==='wrench') { m = new THREE.Group(); m.add(createVoxelBox(0.5, 3, 0.5, CONFIG.colors.wrench, 0, 0, 0)); m.add(createVoxelBox(1.5, 0.8, 0.5, CONFIG.colors.wrench, 0, 1.2, 0)); m.userData = {type:'wrench'}; }
            else { m = new THREE.Group(); const core = createVoxelBox(2, 2, 2, CONFIG.colors.cloud, 0, 0, 0); const p1 = createVoxelBox(1.5, 1.5, 1.5, CONFIG.colors.cloud, 1.2, 0, 0); const p2 = createVoxelBox(1.5, 1.5, 1.5, CONFIG.colors.cloud, -1.2, 0.2, 0); m.add(core, p1, p2); m.userData = {type:'cloud'}; }
            
            const spawnZ = plane.position.z - 400; const spawnX = (Math.random()-0.5) * 70; 
            const h1 = getTerrainHeight(spawnX, spawnZ); const h2 = getTerrainHeight(spawnX - 2, spawnZ); const h3 = getTerrainHeight(spawnX + 2, spawnZ); const safeH = Math.max(h1, h2, h3);
            const spawnY = Math.max(safeH + 4, (Math.random() * 10) - 2);
            m.position.set(spawnX, spawnY, spawnZ); scene.add(m); objects.push(m);
        }

        function spawnParticles(pos, c, count=6) { 
            for(let i=0;i<count;i++){
                let m=new THREE.Mesh(new THREE.BoxGeometry(0.8,0.8,0.8),new THREE.MeshBasicMaterial({color:c}));
                m.position.copy(pos); m.userData={vel:new THREE.Vector3((Math.random()-.5)*3,(Math.random()-.5)*3,(Math.random()-.5)*3)};
                const edges = new THREE.EdgesGeometry(m.geometry); const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color:0x000000})); m.add(line);
                scene.add(m); particles.push(m);
            } 
        }
        
        function checkCollision(plane, obj) {
            const dx = Math.abs(plane.position.x - obj.position.x); const dy = Math.abs(plane.position.y - obj.position.y); const dz = Math.abs(plane.position.z - obj.position.z);
            if (dx < 5 && dy < 2.5 && dz < 3) return true; return false;
        }

        function startGame(){ AudioSys.init(); AudioSys.startMusic(); isPlaying=true;document.getElementById('start-screen').classList.add('hidden');resetLogic(); }
        function togglePause(){ isPaused=!isPaused;document.getElementById('pause-screen').classList.toggle('hidden'); if(isPaused && AudioSys.engineGain) AudioSys.engineGain.gain.value = 0; }
        function resetGame(){document.getElementById('game-over-screen').classList.add('hidden'); document.getElementById('start-screen').classList.remove('hidden');}
        
        function resetLogic(){
            score=0; distance=0; health=100; energy=50; invincibleTimer=0; birdShieldTimer=0;
            gameSpeed=CONFIG.baseSpeed; bounceForce = 0; wallHitTimer = 0; isInputLocked = false;
            objects.forEach(o=>scene.remove(o));objects=[]; particles.forEach(p=>scene.remove(p));particles=[];
            plane.position.set(0,0,0);plane.rotation.set(0,0,0);
            terrainChunks.forEach(c=>scene.remove(c));terrainChunks=[];
            for(let i=0;i<CONFIG.chunkCount;i++)terrainChunks.push(createChunk(-i*CONFIG.chunkSize));
            updateHUD();
        }

        function activateInvincibleBoost() { invincibleTimer = INVINCIBLE_DURATION; AudioSys.boost(); document.getElementById('boost-container').style.opacity = 1; document.getElementById('notif-label').innerText="HYPER VITESSE!"; document.getElementById('notif-label').style.color="#FF00FF"; document.getElementById('notif-label').style.opacity=1; document.getElementById('speed-overlay').style.opacity = 1; }
        function activateBirdShield() { birdShieldTimer = BIRD_SHIELD_DURATION; AudioSys.boost(); document.getElementById('boost-container').style.opacity = 1; document.getElementById('notif-label').innerText="BOUCLIER ANTI-OISEAUX"; document.getElementById('notif-label').style.color="#00FF00"; document.getElementById('notif-label').style.opacity=1; document.getElementById('shield-overlay').style.opacity = 1; }

        function takeDamage(amount) {
             if (invincibleTimer > 0) return; 
             health -= amount; AudioSys.hit(); spawnParticles(plane.position, 0xFF0000); 
             camera.position.x += (Math.random()-0.5)*3; camera.position.y += (Math.random()-0.5)*3; 
             const ov = document.getElementById('damage-overlay'); ov.style.opacity=1; setTimeout(()=>ov.style.opacity=0,200); 
             if(health<=0){ health = 0; isPlaying=false; AudioSys.gameOver(); document.getElementById('final-score').innerText=`${score} PTS`; document.getElementById('final-dist').innerText=`${Math.floor(distance)}M`; document.getElementById('game-over-screen').classList.remove('hidden'); }
             updateHUD();
        }
        
        function healFull() { health = 100; AudioSys.heal(); const ov = document.getElementById('heal-overlay'); ov.style.opacity=1; setTimeout(()=>ov.style.opacity=0,300); updateHUD(); }
        function refillEnergy() { energy = Math.min(100, energy + 50); AudioSys.fuel(); updateHUD(); }

        function updateHUD() { 
            document.getElementById('score-display').innerText=score; document.getElementById('dist-display').innerText=Math.floor(distance) + " m";
            const hb = document.getElementById('health-fill'); hb.style.width = health + "%";
            const eb = document.getElementById('energy-fill'); eb.style.width = energy + "%";
        }

        function animate() {
            requestAnimationFrame(animate); if(isPaused)return;
            if(!isPlaying){ plane.rotation.z=Math.sin(Date.now()*0.001)*0.05; propeller.rotation.z+=0.2; renderer.render(scene, camera); return; }
            
            frameCount++; distance += gameSpeed * 0.1;
            if(wallHitTimer > 0) wallHitTimer--;

            sunMesh.position.z = plane.position.z - 400; sunMesh.position.x = 0; sunMesh.position.y = 30;

            const speedRatio = (gameSpeed - CONFIG.baseSpeed) / (CONFIG.maxBoostSpeed - CONFIG.baseSpeed);
            AudioSys.updateEngine(Math.max(0, speedRatio));

            if (birdShieldTimer > 0) {
                birdShieldTimer--;
                document.getElementById('boost-fill').style.transform = `scaleX(${birdShieldTimer / BIRD_SHIELD_DURATION})`;
                document.getElementById('boost-fill').style.background = "#00FF00";
                if(birdShieldTimer <= 0) { document.getElementById('boost-container').style.opacity = 0; document.getElementById('notif-label').style.opacity = 0; document.getElementById('shield-overlay').style.opacity = 0; }
            }

            if (invincibleTimer > 0) {
                invincibleTimer--; gameSpeed = CONFIG.maxBoostSpeed; 
                document.getElementById('boost-fill').style.transform = `scaleX(${invincibleTimer / INVINCIBLE_DURATION})`;
                document.getElementById('boost-fill').style.background = "#FF00FF";
                if (invincibleTimer <= 0) { gameSpeed = CONFIG.baseSpeed + (distance / 5000); document.getElementById('boost-container').style.opacity = 0; document.getElementById('notif-label').style.opacity = 0; document.getElementById('speed-overlay').style.opacity = 0; }
            } else {
                if (isManualBoosting && energy > 0) { gameSpeed = 3.5; energy -= 0.5; } 
                else { gameSpeed = CONFIG.baseSpeed + (distance / 5000); }
            }
            updateHUD(); 

            if(gameSpeed > 3 && frameCount % 3 === 0) {
                const color = invincibleTimer > 0 ? 0xFF00FF : 0x00FFFF;
                const p = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), new THREE.MeshBasicMaterial({color:color}));
                p.position.copy(plane.position); p.position.z += 2; p.userData = {vel: new THREE.Vector3((Math.random()-.5)*0.5, (Math.random()-.5)*0.5, 2)};
                scene.add(p); particles.push(p);
            }
            
            // INPUT & MOVEMENT (MOBILE & DESKTOP MAPPING)
            let targetX, targetY;
            
            if (isInputLocked) { targetX = 0; targetY = 0; } 
            else {
                // Joystick input (-1 to 1) mapped to game range (60 width, 15 height)
                // Note: on PC, joystick.x is 0, so we can check both
                targetX = (joystick.active ? joystick.x : mouseX) * 60;
                targetY = (joystick.active ? joystick.y : mouseY) * 15;
            }
            
            bounceForce *= 0.9; 
            plane.position.x += (targetX - plane.position.x) * 0.1 + bounceForce; 
            plane.position.y += (targetY - plane.position.y) * 0.1;
            plane.position.z -= gameSpeed;

            const terrainHeight = getTerrainHeight(plane.position.x, plane.position.z);
            if (plane.position.y < terrainHeight + 1.0) {
                if (invincibleTimer > 0) { plane.position.y = terrainHeight + 2; spawnParticles(plane.position, 0xffaa00, 3); } 
                else { takeDamage(20); plane.position.y = terrainHeight + 3; }
            }
            
            if (Math.abs(plane.position.x) > 32) {
                if(invincibleTimer <= 0 && wallHitTimer <= 0) {
                    takeDamage(50); wallHitTimer = 60; isInputLocked = true; setTimeout(() => { isInputLocked = false; }, 500);
                    bounceForce = (plane.position.x > 0) ? -3.5 : 3.5; spawnParticles(plane.position, 0x8B4513, 10);
                } else if(invincibleTimer > 0) {
                    bounceForce = (plane.position.x > 0) ? -1.0 : 1.0;
                }
            }

            plane.rotation.z = -(targetX - plane.position.x) * 0.05 - (bounceForce * 0.5); 
            plane.rotation.x = (targetY - plane.position.y) * 0.03; 
            propeller.rotation.z += (gameSpeed * 0.5);

            let fovTarget = gameSpeed > 2.5 ? 80 : 60; camera.fov += (fovTarget - camera.fov) * 0.05; camera.updateProjectionMatrix();
            camera.position.x += (plane.position.x*0.5 - camera.position.x)*0.1; 
            camera.position.y += (plane.position.y*0.5+8 - camera.position.y)*0.1; 
            camera.position.z = plane.position.z + 24; 
            camera.lookAt(plane.position.x, plane.position.y, plane.position.z - 50);

            if(terrainChunks[0].position.z > plane.position.z + CONFIG.chunkSize) {
                scene.remove(terrainChunks[0]); terrainChunks.shift();
                terrainChunks.push(createChunk(terrainChunks[terrainChunks.length-1].position.z - CONFIG.chunkSize));
            }

            const spawnRate = gameSpeed > 2.5 ? 6 : 10;
            if(frameCount % spawnRate === 0) spawnObject();

            for(let i=objects.length-1; i>=0; i--) {
                let o = objects[i]; 
                
                if(o.userData.type === 'bird') {
                    if (o.userData.dead) { o.position.y -= 1.0; o.rotation.x += 0.2; o.rotation.z += 0.2; } 
                    else { o.userData.wings[0].rotation.z = Math.sin(frameCount * 0.5); o.userData.wings[1].rotation.z = -Math.sin(frameCount * 0.5); o.position.z += 0.4; }
                }
                if(['rocket','wrench','cloud','fuel','missile'].includes(o.userData.type)) o.rotation.y += 0.05;

                if(!o.userData.dead && checkCollision(plane, o)) { 
                    if(o.userData.type==='bird'){ 
                        if (invincibleTimer > 0) { score += 50; AudioSys.smash(); spawnParticles(o.position, 0xff3333, 10); o.userData.dead = true; } 
                        else if (birdShieldTimer > 0) { score += 20; AudioSys.hit(); o.userData.dead = true; }
                        else { takeDamage(20); }
                    }
                    else if(o.userData.type==='rocket') { activateInvincibleBoost(); score+=50; spawnParticles(o.position, CONFIG.colors.rocket, 10); scene.remove(o); objects.splice(i,1); }
                    else if(o.userData.type==='wrench') { healFull(); spawnParticles(o.position, CONFIG.colors.wrench, 10); scene.remove(o); objects.splice(i,1); }
                    else if(o.userData.type==='fuel') { refillEnergy(); spawnParticles(o.position, CONFIG.colors.fuel, 10); scene.remove(o); objects.splice(i,1); }
                    else if(o.userData.type==='missile') { activateBirdShield(); spawnParticles(o.position, CONFIG.colors.missile, 10); scene.remove(o); objects.splice(i,1); }
                    else { score+=10; AudioSys.coin(); spawnParticles(o.position, CONFIG.colors.cloud, 5); scene.remove(o); objects.splice(i,1); } 
                } 
                else if(o.position.z>plane.position.z+20 || o.position.y < -30){scene.remove(o);objects.splice(i,1);}
            }
            
            for(let i=particles.length-1; i>=0; i--){ 
                particles[i].position.add(particles[i].userData.vel); particles[i].rotation.x += 0.1; particles[i].scale.multiplyScalar(0.9); 
                if(particles[i].scale.x<0.05){scene.remove(particles[i]);particles.splice(i,1);} 
            }
            renderer.render(scene, camera);
        }
        init();
    </script>
</body>
</html>